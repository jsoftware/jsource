/* Copyright (c) 1990-2024, Jsoftware Inc.  All rights reserved.           */
/* Licensed use only. Any other use is in violation of copyright.          */
/*                                                                         */
/* Aliases for jt                                                          */


#define BfromD(x,y,z)               jtBfromD(jt,(x),(y),(z))
#define BfromI(x,y)                 jtBfromI(jt,(x),(y))
#define BfromX(x,y)                 jtBfromX(jt,(x),(y))
#define C1fromC2(x,y)               jtC1fromC2(jt,(x),(y))
#define C2fromC1(x,y)               jtC2fromC1(jt,(x),(y))
#define C1fromC4(x,y)               jtC1fromC4(jt,(x),(y))
#define C2fromC4(x,y)               jtC2fromC4(jt,(x),(y))
#define C4fromC1(x,y)               jtC4fromC1(jt,(x),(y))
#define C4fromC2(x,y)               jtC4fromC2(jt,(x),(y))
#define DfromQ(x,y)                 jtDfromQ(jt,(x),(y))
#define DfromX(x,y)                 jtDfromX(jt,(x),(y))
#define DfromZ(x,y,z)               jtDfromZ(jt,(x),(y),(z))
#define DXfI(x,y,z)                 jtDXfI(jt,(x),(y),(z))
#define IfromD(x,y,z)               jtIfromD(jt,(x),(y),(z))
#define IfromX(x,y)                 jtIfromX(jt,(x),(y))
#define QfromD(x,y,z)               jtQfromD(jt,(x),(y),(z))
#define QfromX(x,y)                 jtQfromX(jt,(x),(y))
#define XfromB(x,y)                 jtXfromB(jt,(x),(y))
#define XfromD(x,y,z)               jtXfromD(jt,(x),(y),(z))
#define XfromI(x,y)                 jtXfromI(jt,(x),(y))
#define XfromQ(x,y)                 jtXfromQ(jt,(x),(y))
#define ZfromD(x,y)                 jtZfromD(jt,(x),(y))
#define aaxis(x0,x1,x2,x3,x4,x5,x6,x7)              jtaaxis(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7))
#define abase2(x,y)                 jtabase2(jt,(x),(y),ds(CABASE))
#define ac2(x)                      jtac2(jt,(x))
#define add2(x,y,z)                 jtadd2(jt,(x),(y),(z))
#define afi(x,y)                    jtafi(jt,(x),(y))
#define afrom(x,y)                  jtafrom(jt,(x),(y))
#define afrom2(x0,x1,x2,x3)         jtafrom2(jt,(x0),(x1),(x2),(x3))
#define afzrndID(x,y)               jtafzrndID(jt,(x),(y))
#define aii(x)                      jtaii(jt,(x))
#define aindex(x0,x1,x2)            jtaindex(jt,(x0),(x1),(x2))
#define aindex1(x0,x1,x2,x3)        jtaindex1(jt,(x0),(x1),(x2),(x3))
#define am1a(x0,x1,x2,x3)           jtam1a(jt,(x0),(x1),(x2),(x3))
#define am1e(x0,x1,x2,x3)           jtam1e(jt,(x0),(x1),(x2),(x3))
#define am1sp(x0,x1,x2,x3)          jtam1sp(jt,(x0),(x1),(x2),(x3))
#define amend(x)                    jtamend(jt,(x),ds(CRBRACE))
#define amendn2(x0,x1,x2,x3)        jtamendn2(jt,(x0),(x1),(x2),(x3))
#define amna(x0,x1,x2,x3)           jtamna(jt,(x0),(x1),(x2),(x3))
#define amne(x0,x1,x2,x3)           jtamne(jt,(x0),(x1),(x2),(x3))
#define amnsp(x0,x1,x2,x3)          jtamnsp(jt,(x0),(x1),(x2),(x3))
#define amp(x,y)                    jtamp(jt,(x),(y))
#define ampco(x,y)                  jtampco(jt,(x),(y))
#define apip(x,y)                   jtapip((J)((I)jt|JTINPLACEA),(x),(y))  // use apip instead of over when a is an inplaceable context
#define applystr(x,y)               jtapplystr(jt,(x),(y)) // FIXME: invalid
#define apv(x,y,z)                  jtapv(jt,(x),(y),(z))
#define apvwr(x,y,z)                jtapvwr(jt,(x),(y),(z))
#define arep(x)                     jtarep(jt,(x))
#define aro(x)                      jtaro(jt,(x))
#define ascan(x,y)                  jtascan(jt,(x),(y))
#define aslash(x,y)                 jtaslash(jt,(x),(y))
#define aslash1(x,y)                jtaslash1(jt,(x),(y))
#define assembleresults(x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10)   jtassembleresults(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7),(x8),(x9),(x10))
#define astd1(x,y,z)                jtastd1(jt,(x),(y),(z))
#define astdn(x,y,z)                jtastdn(jt,(x),(y),(z))
#define atab(x,y,z)                 jtatab(jt,(x),(y),(z))
#define atco(x,y)                   jtatco(jt,(x),(y))
#define atcompf(x,y,z)              jtatcompf(jt,(x),(y),(z))
#define atomic(x,y)                 jtatomic(jt,(x),(y))
#define atop(x,y)                   jtatop(jt,(x),(y))

// w is a verb
// result indicates ][ status: 0=none, 1=[ 2=] 3=@[ 4=@]   (or @:)
// idw is id from verb; id is same, but if f@[:}g is replaced by id from g; if id is ][, set bit 0-2 with ][ info, and add @ info; clear it all if not ][
#define atoplr(w) ({I res; if(unlikely(w==0))res=0; else{C idw=FAV(w)->id; A g=FAV(w)->fgh[1]; g=(idw&-2)==CATCO?g:w; res=(idw&-2)==CATCO?3:1; C id=FAV(g)->id; res+=(id&1); res=(id&-2)==CLEFT?res:0;} res;})

#define attu(x)                     jtattu(jt,(x))
#define attv(x)                     jtattv(jt,(x))
#define auditmemchains()            jtauditmemchains(jt)
#define axbytes(x,y)                jtaxbytes(jt,(x),(y))
#define axbytes1(x0,x1,x2,x3,x4)    jtaxbytes1(jt,(x0),(x1),(x2),(x3),(x4))
#define axtally(x,y)                jtaxtally(jt,(x),(y))
#define b0(x)                       jtb0(jt,(x))
#define baddson(x,y,z)              jtbaddson(jt,(x),(y),(z))
#define badjust(x,y)                jtbadjust(jt,(x),(y))
#define base2(x,y)                  jtbase2(jt,(x),(y))
#define bcvt(x,y)                   jtbcvt(jt,(x),(y))
#define bdot(x)                     jtbdot(jt,(x))
#define bdot2(x,y,z)                jtbdot2(jt,(x),(y),(z))
#define behead(x)                   jtbehead(jt,(x))
#define beheadW(x)                  jtbehead((J)((I)jt|JTINPLACEW),(x))
#define bfi(x,y,z)                  jtbfi(jt,(x),(y),(z))
#define bfind(x,y,z)                jtbfind(jt,(x),(y),(z))
#define bfrom(x,y)                  jtbfrom(jt,(x),(y))
#define bigdeal(x,y)                jtbigdeal(jt,(x),(y))
#define bindd(x,y)                  jtbindd(jt,(x),(y))
#define binrep1(x)                  jtbinrep1(jt,(x))
#define binrep2(x,y)                jtbinrep2(jt,(x),(y))
#define binsert(x,y,z)              jtbinsert(jt,(x),(y),(z))
#define binzz(x,y)                  jtbinzz(jt,(x),(y))
#define bitmatch(x,y)               jtbitmatch(jt,(x),(y))
#define bitwise0000(x,y)            jtatomic2(jt,(x),(y),ds(CBW0000))
#define bitwise0001(x,y)            jtatomic2(jt,(x),(y),ds(CBW0001))
#define bitwise0010(x,y)            jtatomic2(jt,(x),(y),ds(CBW0010))
#define bitwise0011(x,y)            jtatomic2(jt,(x),(y),ds(CBW0011))
#define bitwise0100(x,y)            jtatomic2(jt,(x),(y),ds(CBW0100))
#define bitwise0101(x,y)            jtatomic2(jt,(x),(y),ds(CBW0101))
#define bitwise0110(x,y)            jtatomic2(jt,(x),(y),ds(CBW0110))
#define bitwise0111(x,y)            jtatomic2(jt,(x),(y),ds(CBW0111))
#define bitwise1000(x,y)            jtatomic2(jt,(x),(y),ds(CBW1000))
#define bitwise1001(x,y)            jtatomic2(jt,(x),(y),ds(CBW1001))
#define bitwise1010(x,y)            jtatomic2(jt,(x),(y),ds(CBW1010))
#define bitwise1011(x,y)            jtatomic2(jt,(x),(y),ds(CBW1011))
#define bitwise1100(x,y)            jtatomic2(jt,(x),(y),ds(CBW1100))
#define bitwise1101(x,y)            jtatomic2(jt,(x),(y),ds(CBW1101))
#define bitwise1110(x,y)            jtatomic2(jt,(x),(y),ds(CBW1110))
#define bitwise1111(x,y)            jtatomic2(jt,(x),(y),ds(CBW1111))
#define bitwisecharamp(x0,x1,x2,x3) jtbitwisecharamp(jt,(x0),(x1),(x2),(x3))
#define genbitwiserotate(x,y)       jtgenbitwiserotate(jt,(x),(y))
#define genbitwiseshift(x,y)        jtgenbitwiseshift(jt,(x),(y))
#define genbitwiseshifta(x,y)       jtgenbitwiseshifta(jt,(x),(y))
#define box(x)                      jtbox(jt,(x))
#define boxW(x)                     jtbox((J)((I)jt|JTINPLACEW),(x))
#define box0(x)                     irs1((x),0L,0,jtbox)
#define boxatop(x)                  jtboxatop(jt,(x))
#define boxopen(x)                  jtboxopen(jt,(x))   
#define bput(x,y,z)                 jtbput(jt,(x),(y),(z))
#define brep(x,y,z)                 jtbrep(jt,(x),(y),(z))
#define brephdr(x0,x1,x2,x3)        jtbrephdr(jt,(x0),(x1),(x2),(x3))
#define breps(x,y,z)                jtbreps(jt,(x),(y),(z))
#define bsdot(x)                    jtbsdot(jt,(x))
#define bslash(x)                   jtbslash(jt,(x))
#define c2fi(x)                     jtc2fi(jt,(x))
#define c2j(x,y,z,w)                  jtc2j(jt,(x),(y),(z),(w))
#define ca(x)                       jtca(jt,(x))
#define cancel(x,y)                 jtcancel(jt,(x),(y))
#define cant1(x)                    jtcant1(jt,(x),ds(CCANT))
#define cant2(x,y)                  jtcant2(jt,(x),(y)) 
#define canta(x,y)                  jtcanta(jt,(x),(y))
#define cants(x,y,z)                jtcants(jt,(x),(y),(z)) 
#define cap(x)                      jtcap(jt,(x))
#define caro(x)                     jtcaro(jt,(x))
// if we ensured that setting AFRO always removed inplaceability, we could simplify this test
#define makewritable(x)             RZ(x=likely(AC(x)<(AFLAG(x)<<((BW-1)-AFROX)))?x:ca(x))  // OK if AC is 0x8..1 and AFRO is 0
#define mkwris(x)                   jtmkwris(jt,x)
#define case1a(x,y)                 jtcase1a(jt,(x),(y))
#define casev(x)                    jtcasev(jt,(x))
#define catalog(x)                  jtcatalog(jt,(x),ds(CFROM)) 
#define ccvt(x,y,z)                 jtccvt(jt,(x),(y),(z))
#define cdexec1(x0,x1,x2,x3,x4,x5)  jtcdexec1(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define cdgahash(x)                 jtcdgahash(jt,(x))   
#define cdinsert(x,y)               jtcdinsert(jt,(x),(y))   
#define cdload(x,y,z)               jtcdload(jt,(x),(y),(z))
#define cdlookup(x)                 jtcdlookup(jt,(x))   
#define cdlookupl(x)                jtcdlookupl(jt,(x))   
#define cdot1(x)                    jtcdot1(jt,(x),ds(CCYCLE))   
#define ccapdot2(x,y)                  jtccapdot2(jt,(x),(y),ds(CCYCLE))  
#define cdparse(x,y)                jtcdparse(jt,(x),(y))
#define ceil1(x)                    jtatomic1(jt,(x),ds(CCEIL))
#define celloffset(x,y,z)             jtcelloffset(jt,(x),(y),(z))
#define center(x0,x1,x2,x3)         jtcenter(jt,(x0),(x1),(x2),(x3))
#define cex(x,y,z)                  jtcex(jt,(x),(y),(z))
#define cfd(x)                      jtcfd(jt,(x))
#define cfn(x)                      jtcfn(jt,(x))
#define cfr(x)                      jtcfr(jt,(x))
#define cfrd(x,y)                   jtcfrd(jt,(x),(y))
#define cfrq(x,y)                   jtcfrq(jt,(x),(y))
#define cfrx(x,y)                   jtcfrx(jt,(x),(y))
#define cfrz(x,y)                   jtcfrz(jt,(x),(y))
#define checksi()                   jtchecksi(jt)
#define cirx(x0,x1,x2,x3)           jtcirx(jt,(x0),(x1),(x2),(x3)) 
#define clonelocalsyms(x)           jtclonelocalsyms(jt,(x))
#define clonevirtual(z)             jtclonevirtual(jt,(z))
#define coeff(x)                    jtcoeff(jt,(x))
#define coerce2(x,y,z)              jtcoerce2(jt,(x),(y),(z))
#define colon(x,y)                  jtcolon(jt,(x),(y))
#define colon0(x)                   jtcolon0(jt,(x))
#define compare(x,y)                jtcompare(jt,(x),(y))
#define conall(x,y)                 jtconall(jt,(x),(y))
#define congoto(x,y,z)              jtcongoto(jt,(x),(y),(z))
#define congotoblk(x,y)             jtcongotoblk(jt,(x),(y))
#define congotochk(x,y,z)           jtcongotochk(jt,(x),(y),(z))
#define conjug(x)                   jtatomic1(jt,(x),ds(CPLUS))
#define connum(x,y)                 jtconnum(jt,(x),(y))
#define constr(x,y)                 jtconstr(jt,(x),(y))
#define convert0(x0,x1,x2,x3)       jtconvert0(jt,(x0),(x1),(x2),(x3)) 
#define conword(x,y)                jtconword(jt,(x),(y))
#if !SY_64
#define copyTT(x,y,z,v,w)           jtcopyTT(jt,(x),(y),(z),(v),(w))
#endif
#define cpa(x,y)                    jtcpa(jt,(x),(y))
#define cps(x)                      jtcps(jt,(x))
#define crc2(x,y)                   jtcrc2(jt,(x),(y))
#define crccompile(x)               jtcrccompile(jt,(x))
#define createcycliciterator(x,y)   jtcreatecycliciterator(jt,(x),(y))
#define crcvalidate(x,t)            jtcrcvalidate(jt,(x),(t))
#define crelocalsyms(x,y,t,v,f)     jtcrelocalsyms(jt,(x),(y),(t),(v),(f))
#define csize(x,y)                  jtcsize(jt,(x),(y))
#define cstr(x)                     jtcstr(jt,(x))
#define curtail(x)                  jtcurtail(jt,(x))
#define cut(x,y)                    jtcut(jt,(x),(y))
#define cut02(x,y,z)                jtcut02(jt,(x),(y),(z))
#define cut02m(x,y)                 jtcut02m(jt,(x),(y))
#define cut02v(x,y)                 jtcut02v(jt,(x),(y))
#define cut2(x,y,z)                 jtcut2(jt,(x),(y),(z))
#define cut2bx(x,y,z)               jtcut2bx(jt,(x),(y),(z))
#define cut2sx(x,y,z)               jtcut2sx(jt,(x),(y),(z))
#define cvt(x,y)                    jtcvt(jt,(x),(y))
#if !C_CRC32C
#define cvt0(x)                     jtcvt0(jt,(x))
#endif
#define cvt2bit(x,y)                jtcvt2bit(jt,(x),(y))
#define cvz(x,y)                    jtcvz(jt,(x),(y))
#define daxis(x,y)                  jtdaxis(jt,(x),(y))
#define db1b2(x,y)                  jtdb1b2(jt,(x),(y))
#define dbcall(x)                   jtdbcall(jt,(x))
#define dbin(x,y)                   jtdbin(jt,(x),(y))
#define dbincancel(x0,x1,x2,x3,x4)  jtdbincancel(jt,(x0),(x1),(x2),(x3),(x4))
#define dbjump(x)                   jtdbjump(jt,(x))
#define dbrr(x,y)                   jtdbrr(jt,(x),(y))
#define dbstack(x)                  jtdbstack(jt,(x))
#define dbstop(x,y)                 jtdbstop(jt,(x),(y))
#define dbsig(x,y)                  jtdbsig(jt,(x),(y))
#define dbunquote(x,y,z,w)          jtdbunquote(jt,(x),(y),(z),(w))
#define dcase(x,y)                  jtdcase(jt,(x),(y))
#define dcube(x,y)                  jtdcube(jt,(x),(y))
#define ddtokens(x,y)               jtddtokens(jt,(x),(y))
#define deal(x,y)                   jtdeal(jt,(x),(y),ds(CQUERY))
#define deba(x0,x1,x2,x3)           jtdeba(jt,(x0),(x1),(x2),(x3))
#define debdisp(x)                  jtdebdisp(jt,(x))
#define debsi1(x)                   jtdebsi1(jt,(x))
#define debug()                     jtdebug(jt)
#define decorate(x,y)               jtdecorate(jt,(x),(y))
#define debz()                      jtdebz(jt)
#define decrem(x)                   jtdecrem(jt,(x))
#define deflate(x0,x1,x2,x3)        jtdeflate(jt,(x0),(x1),(x2),(x3))
#define deflateq(x0,x1,x2,x3)       jtdeflateq(jt,(x0),(x1),(x2),(x3))
#define denseit(x)                  jtdenseit(jt,(x))
#define det(x,y)                    jtdet(jt,(x),(y))
#define detd(x)                     jtdetd(jt,(x))
#define detmr(x)                    jtdetmr(jt,(x))
#define detr(x)                     jtdetr(jt,(x))
#define detxm(x,y)                  jtdetxm(jt,(x),(y))
#define detz(x)                     jtdetz(jt,(x))
#define df1(r,x,y)                  (r=((r=(y))?(FAV(r)->valencefns[0])((J)((I)jt|(AT(r)&(ADV|CONJ)?JTXDEFMODIFIER:0)),(x),r,r):r))  // y is self; if not 0, execute (x,self,self).  Put result into r, set r 0 if self=0.
                                              //  r must not = x.  self is evaluated only once.  If we call a modifier, set that flag
#define dfv1(r,x,y)                 (r=((r=(y))?(FAV(r)->valencefns[0])(jt,(x),r,r):r))  // z is self, always a verb
                                              //  r must not = x.  self is evaluated only once.  If we call a modifier, set that flag
#define dfv2(r,x,y,z)                (r=((r=(z))?(FAV(r)->valencefns[1])(jt,(x),(y),r):r))  // z is self, always a verb  Put result into r, set r 0 if self=0.  r must not = x or y.  self is evaluated only once
#define df2(r,x,y,z)                (r=((r=(z))?(FAV(r)->valencefns[1])((J)((I)jt|(AT(r)&(ADV|CONJ)?JTXDEFMODIFIER:0)),(x),(y),r):r))  // z is self; if not 0, execute self on x and y.  Put result into r, set r 0 if self=0.  r must not = x or y.  self is evaluated only once
#define df1ip(r,x,y)                  (r=((r=(y))?(FAV(r)->valencefns[0])((J)(((I)jtinplace&~JTXDEFMODIFIER)|(AT(r)&(ADV|CONJ)?JTXDEFMODIFIER:0)),(x),r,r):r))
#define df2ip(r,x,y,z)                (r=((r=(z))?(FAV(r)->valencefns[1])((J)(((I)jtinplace&~JTXDEFMODIFIER)|(AT(r)&(ADV|CONJ)?JTXDEFMODIFIER:0)),(x),(y),r):r))
#define dfc(x,y)                    jtdfc(jt,(x),(y))
#define dfr(x)                      jtdfr(jt,(x))
#define dfrep(x)                    jtdfrep(jt,(x))
#define dfss1(x,y,i)                jtdfss1(jt,(x),(y),(i))  
#define dfss2(x,y,z,i)              jtdfss2(jt,(x),(y),(z),(i))  
#define dgamma(x)                   jtdgamma(jt,(x))
#define dgcd(x,y)                   jtdgcd(jt,(x),(y))
#define dgrade1(x)                  jtdgrade1(jt,(x)) 
#define dgrade2(x,y)                jtdgrade2(jt,(x),(y))
#define dhead(x,y)                  jtdhead(jt,(x),(y))
#define diag(x,y)                   jtdiag(jt,(x),(y))
#define diff(x)                     jtdiff(jt,(x))
#define diff0(x)                    jtdiff0(jt,(x))
#define diffamp(x)                  jtdiffamp(jt,(x))
#define diffamp0(x)                 jtdiffamp0(jt,(x))
#define dir1(x)                     jtdir1(jt,(x))
#define disp(x,y)                   jtdisp(jt,(x),(y))
#define divide(x,y)                 jtatomic2(jt,(x),(y),ds(CDIV)) 
#define divideAW(x,y)               jtatomic2((J)((I)jt|JTINPLACEA|JTINPLACEW),(x),(y),ds(CDIV)) 
#define divideW(x,y)                jtatomic2((J)((I)jt|JTINPLACEW),(x),(y),ds(CDIV)) 
#define dlcm(x,y)                   jtdlcm(jt,(x),(y))
#define dllsymaddr(x,y)             jtdllsymaddr(jt,(x),(y)) 
#define dloc(x)                     jtdloc(jt,0,(x))
#define dolock(x0,x1,x2,x3)         jtdolock(jt,(x0),(x1),(x2),(x3))
#define dot(x,y)                    jtdot(jt,(x),(y))  
#define dotprod(x,y,z)              jtdotprod(jt,(x),(y),(z))  
#define dpoly(x)                    jtdpoly(jt,(x))
#define dpone(x,y)                  jtdpone(jt,(x),(y))
#define drep(x)                     jtdrep(jt,(x))
#define drop(x,y)                   jtdrop(jt,(x),(y))   
#define dropr(x,y)                  jtdropr(jt,(x),(y)) 
#define drow(x,y,z)                 jtdrow(jt,(x),(y),(z))
#define drr(x)                      jtdrr(jt,(x))  
#define dspell(x,y,z)               jtdspell(jt,(x),(y),(z))
#define dtab(x,y)                   jtdtab(jt,(x),(y))
#define duble(x)                    jtduble(jt,(x))   
#define dx_init(x)                  jtdx_init(jt,(x))
#define dx_next()                   jtdx_next(jt)
#define dx_next30()                 jtdx_next30(jt)
#define dxplus(x,y)                 jtdxplus(jt,(x),(y))
#define eachl(x,y,z)                jteachl(jt,(x),(y),(z))
#define ebar(x,y)                   jtebar(jt,(x),(y))   
#define ebarmat(x,y)                jtebarmat(jt,(x),(y))
#define ebarprep(x0,x1,x2,x3,x4)    jtebarprep(jt,(x0),(x1),(x2),(x3),(x4))
#define ebarvec(x,y)                jtebarvec(jt,(x),(y))
#define eca(x0,x1,x2,x3,x4,x5)      jteca(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define ecd(x0,x1,x2,x3,x4)         jtecd(jt,(x0),(x1),(x2),(x3),(x4))
#define ecm(x0,x1,x2,x3,x4,x5)      jtecm(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define ecm_s1(x0,x1,x2,x3,x4,x5)   jtecm_s1(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define ecm_s2(x0,x1,x2,x3,x4,x5,x6)                jtecm_s2(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6))
#define ecvt(x0,x1,x2,x3,x4)        jtecvt(jt,(x0),(x1),(x2),(x3),(x4))
#define efflev(x,y)                 jtefflev(jt,(x),(y))
#define efmt(x,y)                   jtefmt(jt,(x),(y))
#define efr(z,ar,r)                 (z = ((r)>(ar)?(ar):(r))+(REPSGN(r)&(ar)), z=(z<0)?0:z)  // effective rank: ar is rank of argument, r is rank of verb (may be negative), z becomes rank of argument cell
#define enframe(x)                  jtenframe(jtinplace,(x))
#define enqueue(x,y,z)              jtenqueue(jt,(x),(y),(z))
#define ep(x,y)                     jtep(jt,(x),(y))
#define eps(x,y)                    jteps(jt,(x),(y))    
#define eputc(x)                    jteputc(jt,(x))
#define eputl(x)                    jteputl(jt,(x))
#define eputq(x,y)                  jteputq(jt,(x),(y))
#define eputs(x)                    jteputs(jt,(x))
#define eputv(x)                    jteputv(jt,(x))
#define eq(x,y)                     jtatomic2(jt,(x),(y),ds(CEQ))     
#define eqa(x0,x1,x2)               jteqa(jt,(x0),(x1),(x2))
#define eqd(x,y,z)                  jteqd(jt,(x),(y),(z))
#define eqf(x,y)                    jteqf(jt,(x),(y))
#define eqq(x,y,z)                  jteqq(jt,(x),(y),(z))
#define eqx(x,y,z)                  jteqx(jt,(x),(y),(z))
#define eqnq(x,y,z)                 jteqnq(jt,(x),(y),(z))
#define eqnx(x,y,z)                 jteqnx(jt,(x),(y),(z))
#define equ(x,y)                    jtequ(jt,(x),(y))
#define equ0(x,y)                   jtequ0(jt,(x),(y))
#define equx(x,y)                   jtequx(jt,(x),(y))
#define eqz(x,y,z)                  jteqz(jt,(x),(y),(z))
#define errcap()                    jterrcap(jt)
#define etc(x)                      jtetc(jt,(x))
#define ev12(x,y,z)                 jtev12(jt,(x),(y),(z))
#define eval(x)                     jteval(jt,(x))
#define even(x,y)                   jteven(jt,(x),(y))  
#define every(x,y)                  jtevery(jt,(x),(y)) 
#define every2(x0,x1,x2)            jtevery2(jt,(x0),(x1),(x2)) 
#define everysp(x,y)                jteverysp(jt,(x),(y))
#define evger(x,y)                  jtevger(jt,(x),(y))
#define ex(x)                       jtex(jt,(x))  
#define exec1(x)                    jtexec1(jt,(x),ds(CEXEC))   
#define exec2(x,y)                  jtexec2(jt,(x),(y))   
#define exec2q(x0,x1,x2,x3,x4)      jtexec2q(jt,(x0),(x1),(x2),(x3),(x4)) 
#define exec2r(x0,x1,x2,x3,x4,x5)   jtexec2r(jt,(x0),(x1),(x2),(x3),(x4),(x5)) 
#define exec2x(x0,x1,x2,x3,x4)      jtexec2x(jt,(x0),(x1),(x2),(x3),(x4)) 
#define exec2z(x0,x1,x2,x3,x4)      jtexec2z(jt,(x0),(x1),(x2),(x3),(x4))
#define exg(x)                      jtexg(jt,(x))
#define expand(x,y)                 jtexpand(jt,(x),(y))
#define expn1(x)                    jtatomic1(jt,(x),ds(CEXP))   
#define expn2(x,y)                  jtatomic2(jt,(x),(y),ds(CEXP))   // bypass sqrt test for internal calls  
#define exprndID(x,y)               jtexprndID(jt,(x),(y))  
#define ext(x,y)                    jtext(jt,(x),(y))
#define exta(x0,x1,x2,x3)           jtexta(jt,(x0),(x1),(x2),(x3))
#define extnvr(x)                    jtextnvr(jt,(x))
// Handle top level of fa(), which decrements use count and decides whether recursion is needed.  We recur if the contents are traversible and
// the current block is being decremented to 0 usecount or does not have recursive usecount
// fa() audits the tstack, for use outside the tpop system.
// Zczero is ~0 if usecount is going negative, 0 otherwise.  Usecount 1->0, 8..1->8..2, 4..0 unchanged, others decrement
// fa() usually results in a free, coming mostly from freeing named values where the usecount is 1, and the RFO cycle is unnecessary
// NOTE: famf() could be used to preserve a register, if we could find one to preserve
#define faaction(jt,x, nomfaction) {I Zc=AC(x); I tt=AT(x); if(likely(((Zc-2)|tt)<0)){jtfamf(jt,x,tt);}else{if(likely(!ACISPERM(Zc))){if(unlikely(__atomic_fetch_sub(&AC(x),1,__ATOMIC_ACQ_REL)<2))jtfamf(jt,x,tt); else nomfaction}}}  // call if sparse or ending; never touch a PERM
// faowed() is used to free values that were protected on the execution stack.  They will only actually be freed if they were deleted by name (possibly in another thread)
// Thus we mark the free as unlikely, and it will usually do the RFO cycle.  The block must be recursive if it is recursible
#define faowed(x,Zc,tt) {if(unlikely(((Zc-2)|tt)<0)){jtfamf(jt,x,tt);}else{if(likely(!ACISPERM(Zc))){if(unlikely(__atomic_fetch_sub(&AC(x),1,__ATOMIC_ACQ_REL)<2))jtfamf(jt,x,tt);}}}  // call if sparse or ending; never touch a PERM
// faifowed does the free only if the block is marked FAOWED in stkf.  These may have been stacked by local names, if the stack was later protected
#define faifowed(x,Zc,tt,stkf) {if(unlikely(tt<0) || ((((Zc>>(ACPERMANENTX-(STKFAOWEDX+1)))&(4*STKFAOWED-1))<((I)stkf&STKFAOWED)) && unlikely(__atomic_fetch_sub(&AC(x),1,__ATOMIC_ACQ_REL)<2)))jtfamf(jt,x,tt);}  // call if sparse or ending; never touch a PERM
   // FAOWED becomes ..0f0; perm becomes .0p00 where perhaps p00 has +-1 added; 0f0>p00 means 'FAOWED & not PERMANENT'
#define fajt(jt,x) {if(likely((x)!=0))faaction(jt,(x),{if(MEMAUDIT&2)audittstack(jt);})}

#define fa(x) fajt(jt,(x))  // when the block will usually NOT be deleted
#define falikely(x) fa(x)  // when the block will usually be deleted  (not used yet)
#define fatype(x,tt) fa(x) // scaf
//obsolete {if(likely(AC(x)<=ACUC1)){jtfamf(jt,x,tt);}else{if(likely(!ACISPERM(AC(x)))){if(unlikely(__atomic_fetch_sub(&AC(x),1,__ATOMIC_ACQ_REL)<2))jtfamf(jt,x,tt);}}}  // when type is known (i. e. NAME)
#define fanamedacv(x) {I Zc=AC(x); if(likely(!ACISPERM(Zc)))if(unlikely(__atomic_fetch_sub(&AC(x),1,__ATOMIC_ACQ_REL)<2))jtfamf(jt,x,AT(x));} // block is known to be ACV, recursive, AC>0, and almost always AC>1
// when x is known to be valid and usecount has gone to 0
#define fanano0(x)                  faaction(jt,(x),;)
// Within jtfamf when we know the usecount has gone to 0, no need to audit fa, since it was checked on the push.
#define fana(x)                     {if(likely((x)!=0))faaction(jt,(x),;)}
// Within tpop, no need to check ACISPERM; usecount has gone to 0; and we should recur only if flag indicates RECURSIBLE.  In that case we can reconstruct the type from the flag
#define fanapop(x,flg)              jtfamf(jt,(x),(flg)&RECURSIBLE);
// At end of task, we FA() blocks that were known to have been ra()d.  Their usecount cannot be negative, but they may be virtual or sparse.  If virtual when usecount goes to 0, fa the backer and suppress traversal
#define faafterrav(x)  {I Zc=AC(x); I tt=AT(x); if(likely(!ACISPERM(Zc))){if(unlikely((tt|(__atomic_fetch_sub(&AC(x),1,__ATOMIC_ACQ_REL)-2))<0)){if(unlikely(AFLAG(x)&AFVIRTUAL)){fa(ABACK(x)); tt=0;} jtfamf(jt,x,tt);}} }
#define fac_ecm(x)                  jtfac_ecm(jt,(x))
#define facit(x)                    jtfacit(jt,(x))
#define fact(x)                     jtatomic1(jt,(x),ds(CBANG))
#define factor(x)                   jtfactor(jt,(x))
#define fauxblock(z) I __attribute__((aligned(CACHELINESIZE))) z[NORMAH+4]  // define a block that can be passed in to fauxvirtual.  The 4 is the max rank, and must match fauxvirtual and fauxplain
#define fauxblockINT(z,n,r) I __attribute__((aligned(CACHELINESIZE))) z[(AKXR(r)>>LGSZI)+(n)]   // define a block, big enough to hold n atoms at rank r, for use in fauxINT/fauxBOX
// Allocate an INT block. z is the zvalue to hold the result; v is the fauxblock to use if n INTs will fit in the fauxblock, which has rank r
// shape is not filled in, except when rank is 1
#define fauxINT(z,v,n,r) {if(likely(AKXR(r)+(n)*SZI<=(I)sizeof(v))){z=(A)(v); AK(z)=AKXR(r); AFLAGFAUX(z,0) AT(z)=INT; ACFAUX(z,ACUC1); AN(z)=(n); AR(z)=(RANKT)(r); if(r==1)AS(z)[0]=(n);}else{GATV0(z,INT,(n),(r));}}
#define fauxBOX(z,v,n,r) {if(likely(AKXR(r)+(n)*SZI<=(I)sizeof(v))){z=(A)(v); AK(z)=AKXR(r); AFLAGFAUX(z,0) AT(z)=BOX; ACFAUX(z,ACUC1); AN(z)=(n); AR(z)=(RANKT)(r); if(r==1)AS(z)[0]=(n);}else{GATV0(z,BOX,(n),(r));}}
// use the following in functions that cannot admit a return.  You must know that the allocated fauxblock is big enough
#define fauxBOXNR(z,v,n,r) {z=(A)(v); AK(z)=AKXR(r); AFLAGFAUX(z,0) AT(z)=BOX; ACFAUX(z,ACUC1); AN(z)=(n); AR(z)=(RANKT)(r); if(r==1)AS(z)[0]=(n);}
// v is a block declared by fauxblock, w is the source data, r is the rank.  offset is assumed 0.  c is the initial value for AC.  If the rank is small enough, we use the fauxblock, otherwise
// we allocate a block.  We assume that the caller will fill in AN, AS.  Block must be marked UNINCORPABLE so it will not free its backer if freed, and so it will not be in-place virtualed,
// and must be marked recursive if it is of such a type so that if we fa() the block we will not try to recur
// PRISTINE is inherited from the backer (this is not done in virtual(), perhaps it should), because we know the block will never be inplaced unless it was inplaceable at the time this fauxblock was
// created, which means it is not extant anywhere it could be assigned or extracted from.
#define fauxvirtualcommon(z,v,w,r,c,err) {if(likely((r)<=4)){z=ABACK(w); AK((A)(v))=(CAV(w)-(C*)(v)); AT((A)(v))=AT(w); AR((A)(v))=(RANKT)(r); z=AFLAG(w)&AFVIRTUAL?z:(w); \
                              AFLAG((A)(v))=AFVIRTUAL|AFUNINCORPABLE|(AFLAG(z)&AFPRISTINE)|(AT(w)&TRAVERSIBLE); ABACK((A)(v))=z; z=(A)(v); ACFAUX(z,(c))} \
                              else{if(unlikely((z=virtual((w),0,(r)))==0))err; AFLAGORLOCAL(z,AFUNINCORPABLE) if((c)!=ACUC1)ACINIT(z,(c))} }
#define fauxvirtual(z,v,w,r,c) fauxvirtualcommon(z,v,w,r,c,R 0)
// for function definition we don't call a subroutine, because that results in pushing all the arguments, popping them, and storing them back.
// furthermore, we do better to allocate the block early, before the fill has been calculated so that (1) values can be dropped in as they are calculated (2) there is no
// register-destroying subroutine call at the end of the function using fdef
#define fdefallo(z) GAT0(z,INT,(VERBSIZE+SZI-1)>>LGSZI,0)  // allocate as INT to avoid fill-in: we initialize everything
// create a block for a function (verb/adv/conj).  The meanings of all fields depend on the function executed in f1/f2
// if there has been a previous error this function returns 0
// This creates a recursive block and raises fgh
#define fdeffillall(fffz,fffflag2v,fffidv,ffft,ffff1,ffff2,ffffs,fffgs,fffhs,fffflagv,fffm,fffl,fffr,ffflui0,ffflui1) \
{V *fffv=FAV(fffz); \
fffv->valencefns[0]=(ffff1);  /* monad C function */ \
fffv->valencefns[1]=(ffff2); /* dyad  C function */ \
/* AN is unfilled */ \
fffv->flag  =(UI4)(fffflagv); \
fffv->flag2 = (UI4)(fffflag2v); \
fffv->mr    =(RANKT)(fffm);                   /* monadic rank     */ \
fffv->lrr=(RANK2T)(((fffl)<<RANKTX)+(fffr)); /* left/right rank */ \
fffv->id    =(C)(fffidv);                  /* spelling         */ \
ffflui0; ffflui1;  /* local-use fields - store last in case it overwrites an earlier value */ \
/* do the INCORPs last to allow reg vbls to be stored first */ \
A fffasg=(ffffs); if(likely(fffasg!=0))INCORPRA(fffasg); fffv->fgh[0]=fffasg;  /* incorp fs and install as f */ \
fffasg=(fffgs); if(likely(fffasg!=0))INCORPRA(fffasg); fffv->fgh[1]=fffasg;  /* incorp gs and install as g */ \
fffasg=(fffhs); if(likely(fffasg!=0))INCORPRA(fffasg); fffv->fgh[2]=fffasg;  /* incorp hs/other stuff and install as h */ \
AT(fffz)=(ffft); AFLAGINIT(fffz,(ffft)&RECURSIBLE); /* install actual type.  Wait till here so audits of the incomplete block don't fail if realize happens, or we abort with unfilled fgh */ \
}
// fdeffill replaces the original fdef, which did not know about localuse
#define fdeffill(fffz,flag2,id,t,f1,f2,fs,gs,hs,flag,m,l,r) fdeffillall(fffz,flag2,id,t,f1,f2,fs,gs,hs,flag,m,l,r,fffv->localuse.lu0.cachedloc=0,fffv->localuse.lu1.cct=0.0)
#define fdef(flag2,id,t,f1,f2,fs,gs,hs,flag,m,l,r) ({A fffz; fdefallo(fffz) fdeffill(fffz,flag2,id,t,f1,f2,fs,gs,hs,flag,m,l,r) fffz;})  // we no longer check error.  This cannot return 0
#define fdefnoerr(flag2,id,t,f1,f2,fs,gs,hs,flag,m,l,r) ({A fffz; GAT0E(fffz,INT,(VERBSIZE+SZI-1)>>LGSZI,0,goto retpoint) fdeffill(fffz,flag2,id,t,f1,f2,fs,gs,hs,flag,m,l,r) retpoint:; fffz;})  // this version returns 0 if allocation error

#define fdep(x)                     0
#define fdepger(x)                  jtfdepger(jt,(x))
#define filler(x)                   jtfiller(jt,(x))  
#define fillv0(x)               jtfillv0(jt,(x))
#define findnl(x)                   jtfindnl(jt, (x))
// x is locale number, result is address of symbol table, or 0 if nonexistent locale
// only for non-reuse #define findnlz(x,z)                {if((UI)(n)>=jt->numlocsize)z=0; else {z=(A)(jt->numloctbl[n]); z=((UI)((I*)z-jt->numloctbl)<jt->numlocsize)?0:z;}}
#define fit(x,y)                    jtfit(jt,(x),(y))
#define fix(x,y)                    jtfix(jt,(x),(y))
#define fixa(x,y)                   jtfixa(jt,(x),(y))
#define fixrecursive(x,y)           jtfixrecursive(jt,(x),(y))
#define floor1(x)                   jtatomic1(jt,(x),ds(CFLOOR))
#define fmfill(x0,x1,x2,x3,x4,x5,x6,x7) jtfmfill(jtinplace,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7))
#define fminit(x0,x1,x2,x3,x4,x5,x6)   jtfminit(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6))
#define fminus(x,y)                 jtfminus(jt,(x),(y))
#define fmt02(x,y)                  jtfmt02(jt,(x),(y))
#define fmt1(x0,x1,x2,x3,x4,x5,x6)  jtfmt1(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6))
#define fmt12(x,y)                  jtfmt12(jt,(x),(y))
#define fmt22(x,y)                  jtfmt22(jt,(x),(y))
#define fmtallcol(x,y,z)            jtfmtallcol(jt,(x),(y),(z))
#define fmtbfc(x)                   jtfmtbfc(jt,(x))
#define fmtcomma(x0,x1,x2,x3)       jtfmtcomma(jt,(x0),(x1),(x2),(x3))
#define fmtD(x,y)                   jtfmtD(jt,(x),(y))
#define fmtex(x0,x1,x2,x3,x4,x5,x6,x7,x8)              jtfmtex(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7),(x8))
#define fmtprecomp(x,y)             jtfmtprecomp(jt,(x),(y))
#define fmtq(x0,x1,x2,x3,x4,x5,x6)  jtfmtq(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6))
#define fmtx(x0,x1,x2,x3,x4,x5,x6)  jtfmtx(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6))
#define fmtxi(x0,x1,x2,x3)          jtfmtxi(jt,(x0),(x1),(x2),(x3))
#define fname(x)                    jtfname(jt,(x))
#define fnegate(x)                  jtfnegate(jt,(x))
#define fnum(x)                     jtfnum(jt,(x))
#define folk(x,y,z)                 jtfolk(jt,(x),(y),(z))
#define folknohfn(x,y,z)            jtfolk((J)((I)jt|JTFOLKNOHFN),(x),(y),(z))
#define fong(x,y)                   jtfong(jt,(x),(y))
#define foreign(x,y)                jtforeign(jt,(x),(y))
#define foreignextra(x,y)           jtforeignextra(jt,(x),(y))
#define forinit(x,y)                jtforinit(jt,(x),(y))
#define fplus(x,y)                  jtfplus(jt,(x),(y))
#define fpoly(x,y)                  jtfpoly(jt,(x),(y))
#define fpolyc(x)                   jtfpolyc(jt,(x))
#define frcommon(x,f)               {if(likely((x)!=0)){I Zs = AC(x); if(likely(Zs<=1)){f(x);} else if(likely(!ACISPERM(Zs))){if(__atomic_fetch_add(&AC(x),-1,__ATOMIC_ACQ_REL)<0)f(x);}}}  // use fr for known nonrecursives, and for locales
#define fr(x)                       frcommon(x,mf)
#define frgmp(x)                    frcommon(x,mfgmp) // to free GMP blocks
#define mfgmp(x)                    gmpmfree(x)  // to free GMP blocks
#define fram(x0,x1,x2,x3,x4)        jtfram(jt,(x0),(x1),(x2),(x3),(x4))   
#define from(x,y)                   jtfrom(jt,(x),(y),ds(CFROM))   
#define fromA(x,y)                  jtfrom((J)((I)jt|JTINPLACEA),(x),(y),ds(CFROM))  // a arg is not reused
#define frombs(x,y)                 jtfrombs(jt,(x),(y))
#define frombs1(x,y,z)              jtfrombs1(jt,(x),(y),(z))
#define frombsn(x,y,z)              jtfrombsn(jt,(x),(y),(z))
#define frombu(x,y,z)               jtfrombu(jt,(x),(y),(z))
#define fromis(x,y)                 jtfromis(jt,(x),(y))
#define fromis1(x0,x1,x2,x3)        jtfromis1(jt,(x0),(x1),(x2),(x3))
#define fromr(x,y)                  jtfromr(jt,(x),(y))
#define fromsd(x,y)                 jtfromsd(jt,(x),(y))
#define fromss(x,y)                 jtfromss(jt,(x),(y))
#define fsm0(x,y,z)                 jtfsm0(jt,(x),(y),(z))
#define fsmdo(x0,x1,x2,x3,x4,x5)    jtfsmdo(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define fsmvfya(x)                  jtfsmvfya(jt,(x))
#define ftymes(x,y)                 jtftymes(jt,(x),(y))
#define fullname(x)                 jtfullname(jt,(x))
#define fx(x)                       jtfx(jt,(x),0L) 
#define fxchar(x,y)                 jtfxchar(jt,(x),(y))
#define fxeach(x,y)                 jtfxeach(jt,(x),(y))
#define fxeachv(x,y)                jtfxeachv(jt,(x),(y))
#define gaf(x0)                     jtgaf(jt,(x0))
#define gafv(x0)                    jtgafv(jt,(x0))
#define gadv(x)                     jtgadv(jt,(x))
#define gah(x,y)                    jtgah(jt,(x),(y))
#define gaussdet(x)                 jtgaussdet(jt,(x))
#define gausselm(x)                 jtgausselm(jt,(x),DUMMYSELF)
#define gb_flip_cycle()             jtgb_flip_cycle(jt)
#define gb_init(x)                  jtgb_init(jt,(x))
#define gb_next()                   jtgb_next(jt)
#define gb_unif_rand(x)             jtgb_unif_rand(jt,(x))
#define gc(x,y)                     jtgc(jt,(x),(y))
#define gc3(x0,x1,x2,x3)            jtgc3(jt,(x0),(x1),(x2),(x3))
#define gcd(x,y)                    jtatomic2(jt,(x),(y),ds(CPLUSDOT)) 
#define gconj(x,y)                  jtgconj(jt,(x),(y))   
#define ge(x,y)                     jtatomic2(jt,(x),(y),ds(CGE)) 
#define gerexact(x)                 jtgerexact(jt,(x)) 
#define gerfrom(x,y)                jtgerfrom(jt,(x),(y))
#define getsen(x)                   jtgetsen(jt,(x))
#define gjoin(x,y,z)                jtgjoin(jt,(x),(y),(z))   
extern void jfree4gmp(void*,size_t);
#define gmpmfree(x)                 if(!(ACISPERM(AC(x)))){I allocsize = AN(x)+AKXR(1); jt->bytes-=allocsize; jt->malloctotal-=allocsize; jt->mfreegenallo-=allocsize; /*free(x);*/ jfree4gmp(CAV1(x),AN(x));}
#define gr1(x)                      jtgr1(jtinplace,(x))
#define gr2(x,y)                    jtgr2(jtinplace,(x),(y))
#define grade1(x)                   jtgrade1(jt,(x))
#define grade1p(x,y)                jtgrade1p(jt,(x),(y))
#define grade2(x,y)                 jtgrade2(jt,(x),(y))
#define graft(x)                    jtgraft(jt,(x))
#define grb(x0,x1,x2,x3,x4)         jtgrb(jt,(x0),(x1),(x2),(x3),(x4))
#define grc(x0,x1,x2,x3,x4)         jtgrc(jt,(x0),(x1),(x2),(x3),(x4))
#define grd(x0,x1,x2,x3,x4)         jtgrd(jt,(x0),(x1),(x2),(x3),(x4))
#define grd1sp(x)                   jtgrd1sp(jtinplace,(x))
#define grd1spdd(x,y,z)             jtgrd1spdd(jtinplace,(x),(y),(z))
#define grd1spds(x,y,z)             jtgrd1spds(jtinplace,(x),(y),(z))
#define grd1spsd(x,y,z)             jtgrd1spsd(jtinplace,(x),(y),(z))
#define grd1spss(x,y,z)             jtgrd1spss(jtinplace,(x),(y),(z))
#define grd1spz(x,y,z)              jtgrd1spz(jt,(x),(y),(z))
#define grd2sp(x,y)                 jtgrd2sp(jtinplace,(x),(y))
#define grd2spsd(x,y,z)             jtgrd2spsd(jtinplace,(x),(y),(z))
#define grd2spss(x,y,z)             jtgrd2spss(jtinplace,(x),(y),(z))
#define gri(x0,x1,x2,x3,x4)         jtgri(jtinplace,(x0),(x1),(x2),(x3),(x4))
#define gri1(x0,x1,x2,x3,x4)        jtgri1(jtinplace,(x0),(x1),(x2),(x3),(x4))
#define gru(x0,x1,x2,x3,x4)         jtgru(jt,(x0),(x1),(x2),(x3),(x4))
#define gru1(x0,x1,x2,x3,x4)        jtgru1(jtinplace,(x0),(x1),(x2),(x3),(x4))
#define grs(x0,x1,x2,x3,x4)         jtgrs(jt,(x0),(x1),(x2),(x3),(x4))
#define grx(x0,x1,x2,x3,x4)         jtgrx(jtinplace,(x0),(x1),(x2),(x3),(x4))
#define gt(x,y)                     jtatomic2(jt,(x),(y),ds(CGT))     
#define halve(x)                    jthalve(jt,(x))
#define head(x)                     jthead(jt,(x))
#define hgcoeff(x,y)                jthgcoeff(jt,(x),(y))
#define hgd(x0,x1,x2,x3,x4)         jthgd(jt,(x0),(x1),(x2),(x3),(x4))
#define hgdiff(x)                   jthgdiff(jt,(x))
#define hgeom(x,y)                  jthgeom(jt,(x),(y)) 
#define hgeom2(x,y,z)               jthgeom2(jt,(x),(y),(z))
#define hgv(x0,x1,x2,x3)            jthgv(jt,(x0),(x1),(x2),(x3))
#define hia(x,y)                    jthia(jt,(x),(y))
#define hiau(x)                     jthiau(jt,(x))
#define hid(x)                      jthid(jt,(x))
#define hook(x,y,z)                 jthook(jt,(x),(y),(z))
#define hook1(x,y)                  jthook1(jt,(x),(y))
#define hparm(x,y,z)                jthparm(jt,(x),(y),(z))
#define hrep(x,y,z)                 jthrep(jt,(x),(y),(z))
#define i0(x)                       jti0(jt,(x))
#define iaddr(x0,x1,x2,x3)          jtiaddr(jt,(x0),(x1),(x2),(x3))
#define icap(x)                     jticap(jt,(x),ds(CICAP))
#define icor(x,y)                   jticor(jt,(x),(y))  
#define icube(x)                    jticube(jt,(x))
#define icvt(x)                     jticvt(jt,(x))    
#define iden(x)                     jtiden(jt,(x)) 
#define idensb(x)                   jtidensb(jt,(x)) 
#define idenv0(x0,x1,x2,x3,x4)      jtidenv0(jt,(x0),(x1),(x2),(x3),(x4)) 
#define ifb(x,y)                    jtifb(jt,(x),(y))
#define ifc2(x)                     jtifc2(jt,(x))
#define ifdz(x)                     jtifdz(jt,(x))
#define ifrom(x,y)                  jtifrom(jt,(x),(y))
#define ifxi(x,y)                   jtifxi(jt,(x),(y))   
#define igcd(x,y)                   jtigcd(jt,(x),(y))   
#define iindx(x,y)                  jtiindx(jt,(x),(y))
#define iixBX(x0,x1,x2,x3,x4)       jtiixBX(jt,(x0),(x1),(x2),(x3),(x4)) 
#define iixI(x0,x1,x2,x3,x4)        jtiixI(jt,(x0),(x1),(x2),(x3),(x4)) 
#define ilcm(x,y)                   jtilcm(jt,(x),(y))   
#define immea(x)                    jtimmea(jt,(x))
#define immex(x)                    jtimmex(jt,(x))
#define incorp(x)                   jtincorp(jt,(x))  
#define increm(x)                   jtincrem(jt,(x))  
#define indexof(x,y)                jtindexof(jt,(x),(y))
#define indexofprehashed(x,y,z)     jtindexofprehashed(jt,(x),(y),(z),self)
#define indexofss(x,y,z)            jtindexofss(jt,(x),(y),(z))
#define indexofsub(x,y,z)           jtindexofsub(jt,(x),(y),(z))
#define indexofxx(x,y,z)            jtindexofxx(jt,(x),(y),(z))
#define infix(x,y,z)                jtinfix(jt,(x),(y),(z))
#define infix2(x,y,z)               jtinfix2(jt,(x),(y),(z))
#define inpl(x,y,z)                 jtinpl(jt,(x),(y),(z))
#define int0(x)                     jtint0(jt,(x))
#define intdiv(x,y)                 jtintdiv(jt,(x),(y))
#define intg(x)                     jtintg(jt,(x))
#define intg0(x)                    jtintg0(jt,(x))
#define intgamp0(x)                 jtintgamp0(jt,(x))
#define intgatop(x,y)               jtintgatop(jt,(x),(y))
#define intgtymes(x,y)              jtintgtymes(jt,(x),(y))
#define intmod2(x,y)                jtintmod2(jt,(x),(y))
#define intpow(x,y)                 jtintpow(jt,(x),(y))
#define inv(x)                      jtinv(jt,(x),0)
#define invrecur(x)                 jtinv(jt,(x),1)  // call inv(), indicating recursive call
#define invamp(x,y,z)                 jtinvamp(jt,(x),(y),(z))
#define invfork(x)                  jtinvfork(jt,(x))
#define iocol(x,y,z)                jtiocol(jt,(x),(y),(z))
#define ioe(x,y)                    jtioe(jt,(x),(y))
#define ioi(x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12)  jtioi(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7),(x8),(x9),(x10),(x11),(x12))
#define iopart(x0,x1,x2,x3,x4,x5,x6)                jtiopart(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6))
#define ioresparse(x,y,z)           jtioresparse(jt,(x),(y),(z))
#define ioev(x,y)                   jtioev(jt,(x),(y))
#define iovsd(x,y,z)                jtiovsd(jt,(x),(y),(z))
#define iovxs(x,y,z)                jtiovxs(jt,(x),(y),(z))
#define iota(x)                     jtiota(jt,(x),ds(CIOTA))  
#define ipart(x0,x1,x2,x3)          jtipart(jt,(x0),(x1),(x2),(x3))  
#define ipbx(x0,x1,x2,x3)           jtipbx(jt,(x0),(x1),(x2),(x3))  
#define ipoly(x)                    jtipoly(jt,(x))
#define ipprep(x0,x1,x2,x3,x4,x5)   jtipprep(jt,(x0),(x1),(x2),(x3),(x4),(x5)) 
#define iprimetest(x)               jtiprimetest(jt,(x)) 
#define irs1(x0,x1,x2,x3)           jtirs1(jt,(x0),(x1),(x2),(x3))
#define irs2(x0,x1,x2,x3,x4,x5)     jtirs2(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define irs1ip(x0,x1,x2,x3)         jtirs1(jtinplace,(x0),(x1),(x2),(x3))
#define irs2ip(x0,x1,x2,x3,x4,x5)   jtirs2(jtinplace,(x0),(x1),(x2),(x3),(x4),(x5))
#define iscons(x)                   jtiscons(jt,(x))
#define isnanq(x)                   jtisnanq(jt,(x))
#define ispoly(x)                   jtispoly(jt,(x))
#define istd1(x,y)                  jtistd1(jt,(x),(y))
#define ixf(x)                      jtixf(jt,(x))
#define ixin(x0,x1,x2,x3)           jtixin(jt,(x0),(x1),(x2),(x3))
#define jclose(x)                   jtjclose(jt,(x))
#define jdot1(x)                    jtjdot1(jt,(x))   
#define jdot2(x,y)                  jtjdot2(jt,(x),(y)) 
#define jerrno()                    jtjerrno(jt)
#define jfread(x)                   jtjfread(jt,(x),DUMMYSELF)
#define jfwrite(x,y)                jtjfwrite(jt,(x),(y)) // FIXME: invalid
#define jgetenv(x)                  jtjgetenv(jt,(x))
#define jgetx(x)                    jtjgetx(jt,(x))
#define jgets(x)                    jtjgets(jt,(x))
#define jico2(x,y)                  jtjico2(jt,(x),(y))  
#define jinit3()                    jtjinit3(jt)
#define joff(x)                     jtjoff(jt,(x))  
#define joi(x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12)  jtjoi(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7),(x8),(x9),(x10),(x11),(x12))
#define jope(x,y)                   jtjope(jt,(x),(y))
#define jpr(x)                      jtjpr(jt,(x))
#define jpr1(x)                     jtjpr1(jtinplace,(x))
#define jprx(x0,x1,x2,x3,x4)        jtjprx(jt,(x0),(x1),(x2),(x3),(x4))
#define jset(x,y)                   jtjset(jt,(x),(y))
#define jsig(x,y)                   jtjsig(jt,(x),(y))
#define jsigd(x)                    jtjsigd(jt,(x))
#define jsignal(x)                  jtjsignal(jt,(x))
#define jsignal3(x,y,z)             jtjsignal3(jt,(x),(y),(z))
#define jsigstr(x,y,z)              jtjsigstr(jt,(x),(y),(z))
#define jstd(x,y,z,w)                 jtjstd(jt,(x),(y),(z),(w))
#define key(x,y,z)                  jtkey(jt,(x),(y),(z))
#define keyi(x,y,z)                 jtkeyi(jt,(x),(y),(z))
#define keysp(x,y,z)                jtkeysp(jt,(x),(y),(z))
#define keyrs(x,y)                  jtkeyrs(jt,(x),(y))
#define keytally(x,y)             jtkeytally(jt,(x),(y))
#define keytallysp(x)               jtkeytallysp(jt,(x))
#define laguerre(x,y,z)             jtlaguerre(jt,(x),(y),(z))
#define lamin1(x)                   jtlamin1(jt,(x))  
#define lamin2(x,y)                 jtlamin2(jt,(x),(y),ds(CLAMIN)) 
#define lbox(x)                     jtlbox(jtinplace,(x),ltext)
#define lchar(x)                    jtlchar(jtinplace,(x),ltext)
#define lcm(x,y)                    jtatomic2(jt,(x),(y),ds(CSTARDOT))    
#define lcolon(x)                   jtlcolon(jtinplace,(x),ltext) 
#define lcpx(x)                     jtlcpx(jt,(x))
#define le(x,y)                     jtatomic2(jt,(x),(y),ds(CLE))     
#define less(x,y)                   jtless(jt,(x),(y))   
#define lev1(x,y)                   jtlev1(jt,(x),(y))
#define lev2(x,y,z)                 jtlev2(jt,(x),(y),(z))
#define level1(x)                   jtlevel1(jt,(x))
#define levs1(x,y)                  jtlevs1(jt,(x),(y))
#define levs2(x,y,z)                jtlevs2(jt,(x),(y),(z))
#define line(x0,x1,x2,x3)           jtline(jt,(x0),(x1),(x2),(x3))
#define lineit(x)                   jtlineit(jt,(x))
#define linf(x0,x1,x2,x3)           jtlinf(jt,(x0),(x1),(x2),(x3))
#define jlink(x,y)                  jtjlink(jt,(x),(y),DUMMYSELF)  
#define linsert(x,y)                jtlinsert(jtinplace,(x),(y),ltext) 
#define lnoun(x)                    jtlnoun(jtinplace,(x),ltext)
#define lnoun0(x)                   jtlnoun0(jtinplace,(x),ltext)
#define lnum(x)                     jtlnum(jtinplace,(x),ltext)
#define lnum1(x)                    jtlnum1(jtinplace,(x),ltext)
#define locale(x,y)                 jtlocale(jt,(x),(y))
#define loccrenum(x)                jtloccrenum(jt,(x))
#define locdestroy(x)               jtlocdestroy(jt,(x))
#define locindirect(x,y,z)          jtlocindirect(jt,(x),(y),(z))
#define lock1(x)                    jtlock1(jt,(x))
#define lock2(x,y)                  jtlock2(jt,(x),(y))
#define locmap1(x)                  jtlocmap1(jt,0,(x))
#define locname(x)                  jtlocname(jt,(x))
#define locnlx(x,y,z)                 jtlocnlx(jt,(x),(y),(z))
#define logar1(x)                   jtatomic1(jt,(x),ds(CLOG))  
#define lowerupper(x,y)             jtlowerupper(jt,(x),(y))
#define lp(x)                       jtlp(jt,(x))
#define lrv(x)                      ((UI)((x)->lrr)>>RANKTX)  // left rank of V
#define lr(x)                       lrv(FAV(x))  // left rank of A
#define lr2(x,y,z)                  jtlr2(jt,(x),(y),(z))
#define lrep(x)                     jtlrep(jt,(x))
#define lrr(x)                      jtlrr(jtinplace,(x),0L,ltext)
#define lsh(x)                      jtlsh(jtinplace,(x),ltext)
#define lshape(x)                   jtlshape(jtinplace,(x),ltext)
#define lsparse(x)                  jtlsparse(jtinplace,(x),ltext)
#define lsub(x,y,z)                 jtlsub(jt,(x),(y),(z))
#define lsymb(x,y)                  jtlsymb(jtinplace,(x),(y),ltext)
#define lt(x,y)                     jtatomic2(jt,(x),(y),ds(CLT))  
#define ltie(x)                     jtltie(jt,(x))
#define ltrim(x)                    jtltrim(jt,(x))
#define lrtrim(x,y)                 jtlrtrim(jt,(x),(y))
#define ma(x)                       jtma(jt,(x))
#define mag(x)                      jtatomic1(jt,(x),ds(CSTILE))     
#define makename(x,y)               jtmakename(jt,(x),(y))  
#define map(x)                      jtmap(jt,(x))  
#define mapx(x,y)                   jtmapx(jt,(x),(y))  
#define mat(x)                      jtmat(jt,(x))   
#define match(x,y)                  jtmatch(jt,(x),(y))  
#define matchs(x,y)                 jtmatchs(jt,(x),(y))  
#define matchsub(x0,x1,x2,x3,x4,x5,x6,x7)  jtmatchsub(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7))
#define matth1(x,y)                 jtmatth1(jt,(x),(y))
#define maxdenom(x,y)               jtmaxdenom(jt,(x),(y))
#define maximum(x,y)                jtatomic2(jt,(x),(y),ds(CMAX))
#define maxtypene(x,y)              jtmaxtype(jt,(x),(y))
#define maxtype(x,y)                (likely((x)==(y))?(x):maxtypene(x,y))
#define maxtypedne(x,y)             (TYPEPRIORITY(x)>TYPEPRIORITY(y)?(x):(y))  // d means 'dense'
#define maxtyped(x,y)               (likely((x)==(y))?(x):maxtypedne(x,y))
#define typeged(x,y)                (TYPEPRIORITY(x)>=TYPEPRIORITY(y))
// For sparse types, we encode here the corresponding dense type
#define mdiv(x,y)                   jtmdiv(jt,(x),(y)) // FIXME: invalid
#define mdivsp(x,y)                 jtmdivsp(jt,(x),(y)) // FIXME: invalid
#define meanD(x0,x1,x2,x3,x4)       jtmeanD(jt,(x0),(x1),(x2),(x3),(x4))
#define meanI(x0,x1,x2,x3,x4)       jtmeanI(jt,(x0),(x1),(x2),(x3),(x4))
#define memoget(x,y,z)              jtmemoget(jt,(x),(y),(z))
#define memoput(x0,x1,x2,x3)        jtmemoput(jt,(x0),(x1),(x2),(x3))
#define merge1(x,y)                 jtmerge1(jt,(x),(y))
#define merge2(x0,x1,x2,x3,x4)      jtmerge2(jt,(x0),(x1),(x2),(x3),(x4))
#define mf(x)                       jtmf(jt,(x),AFHRH(x),FHRHPOOLBIN(AFHRH(x)))
#define mfgmp(x)                    gmpmfree(x)  // to free GMP blocks
#define minimum(x,y)                jtatomic2(jt,(x),(y),ds(CMIN))
#define minors(x)                   jtminors(jt,(x))
#define minus(x,y)                  jtatomic2(jt,(x),(y),ds(CMINUS))  
#define minusA(x,y)                 jtatomic2((J)((I)jt|JTINPLACEA),(x),(y),ds(CMINUS))  
#define minv(x)                     jtminv(jt,(x))  
#define mkdir1(x)                   jtmkdir1(jt,(x))
#define mmharvest(x0,x1,x2,x3,x4,x5,x6) jtmmharvest(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6))
#define mmprep(x0,x1,x2,x3,x4,x5)   jtmmprep(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define mnomx(x,y)                  jtmnomx(jt,(x),(y))
#define modpow2(x,y,z)              jtmodpow2(jt,(x),(y),(z))
#define move(x,y,z)                 jtmove(jt,(x),(y),(z))
#define movandor(x0,x1,x2,x3)       jtmovandor(jt,(x0),(x1),(x2),(x3))
#define movbwneeq(x0,x1,x2,x3)      jtmovbwneeq(jt,(x0),(x1),(x2),(x3))
#define movfslash(x,y,z)            jtmovfslash(jt,(x),(y),(z))
#define movminmax(x0,x1,x2,x3)      jtmovminmax(jt,(x0),(x1),(x2),(x3))
#define movneeq(x0,x1,x2,x3)        jtmovneeq(jt,(x0),(x1),(x2),(x3))
#define movsumavg(x0,x1,x2,x3)      jtmovsumavg(jt,(x0),(x1),(x2),(x3))
#define movsumavg1(x0,x1,x2,x3)     jtmovsumavg1(jt,(x0),(x1),(x2),(x3))
#define mr(x)                       ((I)(FAV(x)->mr))
#define mr_init(x)                  jtmr_init(jt,(x))
#define mr_next()                   jtmr_next(jt)
#define mr_next31()                 jtmr_next31(jt)
#define msmerge(x,y,z)              jtmsmerge(jt,(x),(y),(z))
#define mt_init_by_array(x,y)       jtmt_init_by_array(jt,(x),(y))
#define mt_init(x)                  jtmt_init(jt,(x))
#define mt_next()                   jtmt_next(jt)
#define mult(x,y)                   jtmult(jt,(x),(y))
#define multiple(x,y)               jtmultiple(jt,(x),(y))
#define mvw(x0,x1,x2,x3,x4,x5,x6)   jtmvw(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6))
#define nameref(x,y)                jtnameref(jt,(x),(y)) 
#define namerefop(x,y)              jtnamerefop(jt,(x),(y)) 
#define namerefacv(x,y)             jtnamerefacv(jt,(x),(y)) 
#define nch1(x0,x1,x2,x3)           jtnch1(jt,(x0),(x1),(x2),(x3))   
#define ne(x,y)                     jtatomic2(jt,(x),(y),ds(CNE))  
#define negate(x)                   jtnegate(jt,(x),ds(CMINUS))
#define negateW(x)                  jtnegate((J)((I)jt|JTINPLACEW),(x),ds(CMINUS))
#define neutral(x)                  jtneutral(jt,(x))
#define newt(x0,x1,x2,x3)           jtnewt(jt,(x0),(x1),(x2),(x3))
#define nextprime(x)                jtnextprime(jt,(x))
#define nfb(x)                      jtnfb(jt,(x))
#define nfs(x,y)                    jtnfs(jt,(x),(y))  
#define nlsym(x,y,z)                  jtnlsym(jt,(x),(y),(z))
#define nlx(x,y)                    jtnlx(jt,(x),(y))
#define nlxxx(x,y)                  jtnlxxx(jt,(x),(y))
#define nmhash(x,y)                 hic((x),(y))
#define nodupgrade(x0,x1,x2,x3,x4,x5,x6,x7,x8)      jtnodupgrade(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7),(x8))
#define nor(x,y)                    jtatomic2(jt,(x),(y),ds(CPLUSCO))  
#define norm(x)                     jtnorm(jt,(x))  
#define not(x)                      jtnot(jt,(x))
#define notW(x)                     jtnot((J)((I)jt|JTINPLACEW),(x))
#define nub(x)                      jtnub(jt,(x))     
#define nubi(x)                     jtnubi(jt,(x))     
#define nubsieve(x)                 jtnubsieve(jt,(x))
#define nubsievesp(x)               jtnubsievesp(jt,(x))
#define numb(x0,x1,x2,x3)           jtnumb(jt,(x0),(x1),(x2),(x3))
#define numbpx(x,y,z)               jtnumbpx(jt,(x),(y),(z))
#define numcase(x0,x1)              jtnumcase(jt,(x0),(x1))
#define numfd(x,y,z)                jtnumfd(jt,(x),(y),(z))
#define numfq(x,y,z)                jtnumfq(jt,(x),(y),(z))
#define nume(x,y,z)                 jtnume(jt,(x),(y),(z))
#define numi(x,y,z)                 jtnumi(jt,(x),(y),(z))
#define numj(x,y,z)                 jtnumj(jt,(x),(y),(z))
#define numq(x,y,z)                 jtnumq(jt,(x),(y),(z))
#define numr(x,y,z)                 jtnumr(jt,(x),(y),(z))
#define numx(x,y,z)                 jtnumx(jt,(x),(y),(z))
#define nvrpop(x)                   jtnvrpop(jt,(x))
#define nvrpush(x)                  jtnvrpush(jt,(x))
#define oblique(x,y)                jtoblique(jt,(x),(y))
#define obqfslash(x,y)              jtobqfslash(jt,(x),(y))
#define obverse(x,y)                jtobverse(jt,(x),(y))
#define odom(x,y,z)                 jtodom(jt,(x),(y),(z))
#define ofxassoc(x,y,z)             jtofxassoc(jt,(x),(y),(z))
#define oind(x)                     jtoind(jt,(x))
#define oldsize(x)                  jtoldsize(jt,(x))
#define omask(x,y)                  jtomask(jt,(x),(y))
#define onf1(x,y)                   jtonf1(jt,(x),(y))
#define onm(x)                      jtonm(jt,(x))     
#define ope(x)                      jtope(jt,(x)) 
#define opes(x,y,z)                 jtopes(jt,(x),(y),(z))
#define opes1(x0,x1,x2,x3,x4,x5)    jtopes1(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define opes2(x0,x1,x2,x3,x4,x5,x6) jtopes2(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6))
#define ord(x)                      jtord(jt,(x))
#define ordstat(x,y)                jtordstat(jt,(x),(y))
#define osub(x,y)                   jtosub(jt,(x),(y))
#define outfix(x,y,z)               jtoutfix(jt,(x),(y),(z))
#define over(x,y)                   jtover(jt,(x),(y),ds(CCOMMA))
#define ovgmove(x0,x1,x2,x3,x4,x5)  jtovgmove(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define ovs(x,y)                    jtovs(jt,(x),(y))
#define ovs0(x0,x1,x2,x3)           jtovs0(jt,(x0),(x1),(x2),(x3))
#define pad(x,y,z)                  jtpad(jt,(x),(y),(z))
#define parse(x)                    jtparse(jt,(x))
#define parseforexec(x)             jtparse((J)((I)jt|JTFROMEXEC),(x))
#define parsea(x,y)                 jtparsea(jt,(x),(y))
#define parsex(x0,x1,x2,x3)         jtparsex(jt,(x0),(x1),(x2),(x3))
#define partfscan(x0,x1,x2,x3,x4,x5)  jtpartfscan(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define pathit(x)                   jtpathit(jt,(x))
#define paxis(x,y)                  jtpaxis(jt,(x),(y))
#define pcvt(x,y)                   jtpcvt(jt,(x),(y))
#define pdef(x0,x1,x2,x3,x4,x5,x6,x7)  jtpdef(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7))
#define pdt(x,y)                    jtpdt(jt,(x),(y))
#define pdtby(x,y)                  jtpdtby(jt,(x),(y))
#define pdtsp(x,y)                  jtpdtsp(jt,(x),(y))
#define pdtspmv(x,y)                jtpdtspmv(jt,(x),(y))
#define pdtspmm(x,y)                jtpdtspmm(jt,(x),(y))
#define pdtspmm0(x,y)               jtpdtspmm0(jt,(x),(y))
#define pdtspmm1(x,y)               jtpdtspmm1(jt,(x),(y))
#define pdtspmm01(x,y)              jtpdtspmm01(jt,(x),(y))
#define pdtspvm(x,y)                jtpdtspvm(jt,(x),(y))
#define pdtspvmmv01(x,y)            jtpdtspvmmv01(jt,(x),(y))
#define pdtspvmmv0or1(x,y)          jtpdtspvmmv0or1(jt,(x),(y))
#define pdtspvv(x,y)                jtpdtspvv(jt,(x),(y))
#define pee(a,b,c,d)                jtpee(jt,(a),(b),(c),(d))
#define pfill(x,y)                  jtpfill(jt,(x),(y))
#define pfxplus(x,y)                ((x)+(y))
#define piev(x,y)                   jtpiev(jt,(x),(y))
#define pind(x,y)                   jtpind(jt,(x),(y))
#define pinit()                     jtpinit(jt)
#define pinv(x)                     jtpinv(jt,(x),DUMMYSELF)
#define pix(x)                      jtpix(jt,(x),ds(CCIRCLE))
#define plt(x)                      jtplt(jt,(x))
#define plus(x,y)                   jtatomic2(jt,(x),(y),ds(CPLUS))   
#define plusA(x,y)                  jtatomic2((J)((I)jt|JTINPLACEA),(x),(y),ds(CPLUS))
#define plusAW(x,y)                 jtatomic2((J)((I)jt|JTINPLACEA|JTINPLACEW),(x),(y),ds(CPLUS))
#define plusW(x,y)                  jtatomic2((J)((I)jt|JTINPLACEW),(x),(y),ds(CPLUS))
#define ply1(x,y)                   jtply1(jt,(x),(y))
#define pmarea2(x,y)                jtpmarea2(jt,(x),(y))
#define pmfree(x)                   jtpmfree(jt,(x))
#define pmrecord(x0,x1,x2,x3)       jtpmrecord(jt,(x0),(x1),(x2),(x3))
#define pollard_p_1(x)              jtpollard_p_1(jt,(x))
#define pollard_rho(x)              jtpollard_rho(jt,(x))
#define poly1(x)                    jtpoly1(jt,(x),ds(CPOLY))   
#define poly2(x,y)                  jtpoly2(jt,(x),(y),ds(CPOLY))
#define poly2a(x,y)                 jtpoly2a(jt,(x),(y)) // FIXME: invalid
#define polymult(x,y,z)             jtpolymult(jt,(x),(y),(z))
#define pospow(x,y)                 jtpospow(jt,(x),(y))
#define powop(x,y,z)                jtpowop(jt,(x),(y),(z)) 
#define powseqlim(x,y)              jtpowseqlim(jt,(x),(y)) 
#define prefix(x,y)                 jtprefix(jt,(x),(y))
#define prep(x)                     jtprep(jt,(x))
#define preparse(x,y,z)             jtpreparse(jt,(x),(y),(z))
#define prevprime(x)                jtprevprime(jt,(x))   
#define prime(x)                    jtprime(jt,(x))   
#define prime1(x)                   jtprime1(jt,(x)) 
#define prime1d(x)                  jtprime1d(jt,(x)) 
#define primetest(x)                jtprimetest(jt,(x)) 
#define primitive(x)                jtprimitive(jt,(x))
#define probex(x,y,z,a,b)           probe(x,y,z,((UI8)(a)<<32)+(UI4)LXAV0(b)[SYMHASH((UI4)(a),AN(b)-SYMLINFOSIZE)])
#define probeis(x,y)                jtprobeis(jt,(x),(y))
#define probeisres(x,y)             jtprobeisres(jt,(x),(y))
#define probeislocal(x,y)           jtprobeislocal(jt,(x),(y))
#define probequiet(x)             jtprobequiet(jt,(x))
#define probelocal(x,y)             jtprobelocal(jt,(x),(y))
#define probenum(x,y)               jtprobenum(jt,(x),(y))  
#define prod(x,y)                   jtprod(jt,(x),(y))
#define pscan(x,y)                  jtpscan(jt,(x),(y))
#define pscangt(x0,x1,x2,x3,x4,x5)         jtpscangt(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define pscanlt(x0,x1,x2,x3,x4,x5)  jtpscanlt(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define qbin(x,y)                   jtqbin(jt,(x),(y))
#define qco2(x,y)                   jtqco2(jt,(x),(y))
#define qco2x(x,y)                  jtqco2x(jt,(x),(y))
#define qcompare(x,y)               jtqcompare(jt,(x),(y))
#define qdiv(x,y)                   jtqdiv(jt,(x),(y))
#define qgcd(x,y)                   jtqgcd(jt,(x),(y))
#define qlcm(x,y)                   jtqlcm(jt,(x),(y))
#define qlogd1(x)                   jtqlogd1(jt,(x))
#define qlogz1(x)                   jtqlogz1(jt,(x))
#define qminus(x,y)                 jtqminus(jt,(x),(y))
#define Qmpq(x)                     jtQmpq(jt,(x))
#define qplus(x,y)                  jtqplus(jt,(x),(y))
#define qpow(x,y)                   jtqpow(jt,(x),(y))
#define qq(x,y)                     jtqq(jt,(x),(y)) 
#define qr(x)                       jtqr(jt,(x))  
#define qrem(x,y)                   jtqrem(jt,(x),(y))
#define qrr(x)                      jtqrr(jt,(x))  
#define qstd(x)                     jtqstd(jt,(x))
#define qtymes(x,y)                 jtqtymes(jt,(x),(y))
#define qquad(z,w)                  jtqquad(jt,(z),(w))
// If this block is recursible and not recursive, execute prolog and then raise the descendants.  Since sharing a block with another thread requires going recursive, the flag operations can be local
#define radescendsv(x,sv)         {I tt=AT(x); {if(unlikely(((tt^AFLAG(x))&TRAVERSIBLE)!=0)){AFLAGORLOCAL((x),(tt)&RECURSIBLE); sv=jtra((x),(tt),sv);}}}  // keep sv in a register
#define radescend(x)         radescendsv(x,x)
// Make a block recursive if it is recursible and not already recursive.  Virtuals are already recursive, as are PERMANENTs.  We use this in a place where we know the result can't be unincorpable.  x might not be a noun
#define ramkrecursv(x)              if(unlikely(((AT(x)^AFLAG(x))&RECURSIBLE))){AFLAGORLOCAL((x),AT(x)&RECURSIBLE); x=jtra(x,AT(x),x);}  // if block is not recursive, it must be local
// make this block recursive, used when x has just been allocated & thus is known to be nonrecursive & nonvirtual.  We may know the type t, too (otherwise use AT(x))
#define ra00(x,tt)                {if(unlikely(((tt)&TRAVERSIBLE)!=0)){AFLAGORLOCAL((x),(tt)&RECURSIBLE); x=jtra((x),(tt),x);}}
// If this is a recursible type, make it recursive if it isn't already, by traversing the descendants.  This is like raising the usecount by 0.  Since we aren't liable to assign the block, we don't have to realize a
// virtual block unless it is a recursible type.  NOTE that PERMANENT and VIRTUAL blocks are always marked recursible if they are of recursible type
#define ra0(x)                      {if(unlikely((AFLAG(x)&AFVIRTUAL)!=0)){RZ((x)=realize(x));}radescend(x)}
// Handle top level of ra().  Increment usecount.  Set usecount recursive usecount if recursible type; recur on contents if original usecount is not recursive
// We can have an inplaceable but recursible block, if it was gc'd or created that way
// ra() DOES NOT realize a virtual block.  ras() does include rifv
#define rasv(x)   {I c=AC(x); if(likely(!ACISPERM(c))){if(c<0)AC(x)=(I)((UI)c+(ACINPLACE+ACUC1));else __atomic_fetch_add(&AC(x),1,__ATOMIC_ACQ_REL); radescend(x,sv)}}  // better a misbranch than an atomic instruction if c<0.  Could avoid recur check if AC>1
#define ra(x)   {I c=AC(x); if(likely(!ACISPERM(c))){if(c<0)AC(x)=(I)((UI)c+(ACINPLACE+ACUC1));else __atomic_fetch_add(&AC(x),1,__ATOMIC_ACQ_REL); radescend(x)}}  // better a misbranch than an atomic instruction if c<0.  Could avoid recur check if AC>1
#define racontents(x)   {I c=AC(x); if(MEMAUDIT!=0&&c<0)SEGFAULT; if(likely(!ACISPERM(c))){__atomic_fetch_add(&AC(x),1,__ATOMIC_ACQ_REL); radescend(x)}}  // Used on contents of box, which cannot have AC<0
#define raname(x) ra(x)  // scaf
// obsolete {if(likely(!ACISPERM(AC(x))))__atomic_fetch_add(&AC(x),1,__ATOMIC_ACQ_REL);}  // NAME is not inplaceable, seldom local; just add 1.  No traverse needed on ra
// In the following pos means the block is known to be assigned already, thus usecount>0 and recursive; acv means known non-noun; gbl means global name (always recursive usecount); local means local symtab
// sv means the last arg is saved/restored through the call; qcg supplies the QC type; uncond means the arg cannot be perm/sparse/need recursion, so just increment
#define rapos(x,sv)   {I c=AC(x); if(likely(!ACISPERM(c))){__atomic_fetch_add(&AC(x),1,__ATOMIC_ACQ_REL); if(unlikely(ISSPARSE(AT(x))))sv=jtra((x),SPARSE,sv);}}  // better a misbranch than an atomic instruction if c<0
#define raposlocal(x,sv)   {I c=AC(x); if(likely(!ACISPERM(c))){if(c==1)AC(x)=ACUC2;else __atomic_fetch_add(&AC(x),1,__ATOMIC_ACQ_REL); if(unlikely(ISSPARSE(AT(x))))sv=jtra((x),SPARSE,sv);}}  // better a misbranch than an atomic instruction if c<0
#define raposacv(x)   {I c=AC(x); if(likely(!ACISPERM(c))){__atomic_fetch_add(&AC(x),1,__ATOMIC_ACQ_REL);}}  // ACV is guaranteed recursive
#define raposgblqcgsv(x,qct,sv) {I c=AC(x); if(likely(!ACISPERM(c))){ACADD(x,1); if(unlikely(qct==VALTYPESPARSE))sv=jtra((x),SPARSE,sv);}}  // must be recursive usecount but may be sparse
#define raposlocalqcgsv(x,qct,sv) {I c=AC(x); if(likely(!ACISPERM(c))){if(c==1)AC(x)=ACUC2;else __atomic_fetch_add(&AC(x),1,__ATOMIC_ACQ_REL); if(unlikely(qct==VALTYPESPARSE))sv=jtra((x),SPARSE,sv);}}  // must be recursive usecount but may be sparse
#define rarecur(x)   {I c=AC(x); if(likely(!ACISPERM(c))){if(c<0)AC(x)=(I)((UI)c+(ACINPLACE+ACUC1));else __atomic_fetch_add(&AC(x),1,__ATOMIC_ACQ_REL); I tt=AT(x); if(unlikely(ISSPARSE(tt)))x=jtra((x),(tt),x);}}  // ra but recursibles know to be recursive
// NOTE that every() produces blocks with usecount 0x8..2 (if a recursive block has pristine contents whose usecount is 2); if we ZAP that it must go to 2
// We cannot simply ZAP every inplaceable value because we need to keep the oldest reference, which is the zap value.  Only OK to zap when the block has just been created.  the tstackend variant checks to see if the value is the end of the stack
#define raczapcommon(x,cond,zapfn)   {I c=AC(x); if(likely(!ACISPERM(c))){if(likely(cond)){zapfn AC(x)=c&=~ACINPLACE;}else{if(c<0)AC(x)=(I)((UI)c+(ACINPLACE+ACUC1));else __atomic_fetch_add(&AC(x),1,__ATOMIC_ACQ_REL);} \
                                    radescend(x)}}
                                    // use ZAP for inplaceable blocks; don't increment PERMANENT blocks.  Use only if x's stack entry is in the current frame
                                    // cond must be true only if c<0
#define raczap(x,cond)              raczapcommon(x,cond,*AZAPLOC(x)=0;)
#define razap(x)                    raczap(x,c<0)  // default case is to zap whenever inplaceable, assuming abandoned
#define razaptstackend(x)           raczapcommon(x,c<0,ZAPTSTACKEND(x))  // default case is to zap whenever inplaceable, assuming abandoned, but also checking to see if we can simply expunge the tstack entry
#define ranec(x0,x1,x2,x3,x4,x5)    jtranec(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define rank1ex(x0,x1,x2,x3)        jtrank1ex(jt,(x0),(x1),(x2),(x3))
#define rank1ex0(x0,x1,x2)          jtrank1ex0(jt,(x0),(x1),(x2))
#define REX2R(lr,rr,lcr,rcr)        (((UI)(lr)<<RANKTX)+(UI)(rr)+((((UI)(lcr)<<RANKTX)+(UI)(rcr))<<RANK2TX))
#define rank2ex(x0,x1,x2,x3,x4,x5,x6,x7)  jtrank2ex(jt,(x0),(x1),(x2),REX2R((x3),(x4),(x5),(x6)),(x7))
#define rank2exip(x0,x1,x2,x3,x4,x5,x6,x7)  jtrank2ex(jtinplace,(x0),(x1),(x2),REX2R((x3),(x4),(x5),(x6)),(x7))
#define rank2ex0(x0,x1,x2,x3)       jtrank2ex0(jt,(x0),(x1),(x2),(x3))
#define rankingb(x0,x1,x2,x3,x4,x5) jtrankingb(jt,(x0),(x1),(x2),(x3),(x4),(x5))
// ras does rifv followed by ra
#define ras(x)                      ((x) = jtras(jt,x))
#define ra00s(x)                    ((x) = jtra00s(jt,x))
#define rat(x)                      jtrat(jt,(x))
#define ravel(x)                    jtravel(jt,(x))   
#define ravelW(x)                   jtravel((J)((I)jt|JTINPLACEW),(x))   
#define raze(x)                     jtraze(jt,(x))    
#define razecut2(x,y,z)             jtrazecut2(jt,(x),(y),(z))    
#define razeg(x0,x1,x2,x3,x4)    jtrazeg(jt,(x0),(x1),(x2),(x3),(x4))
#define razeh(x)                    jtrazeh(jt,(x))    
#define rc(x,y,z,t)                 jtrc(jt,(x),(y),(z),(t)) 
#define rca(x)                      jtrca(jt,(x))
#define rd(x,y,z)                   jtrd(jt,(x),(y),(z)) 
#define rdns(x)                     jtrdns(jt,(x))   
#define rdot1(x)                    jtrdot1(jt,(x))   
#define realize(x)                  jtrealize(jt,(x))
#define realizeboxedvirtuals(x)     jtrealizeboxedvirtuals(jt,(x))
#define realizeifvirtualE(x,f)      {if(unlikely((AFLAG(x)&AFVIRTUAL)!=0))f((x)=realize(x));} // f is the error function, if any
#define realizeifvirtual(x)         realizeifvirtualE(x,RZ)
#define realizeifvirtualB(x)        realizeifvirtualE(x,BZ) // for use in cx, where errors not allowed - treat as BASSERT error
#define realizeifvirtualERR(x,e)    {if(unlikely((AFLAG(x)&AFVIRTUAL)!=0))if(unlikely(((x)=realize(x))==0))e}
#define rifv(x)                     realizeifvirtual(x)
#define rifvs(x)                    jtrifvs(jt,(x))
// We have used rifvs liberally through the code to guarantee that all functions can deal with virtual blocks returned.
// In some cases, the call is to an internal routine that we know will not return a virtual block normally, and is in an
// important performance path.  We use rifvsdebug for these places.  rifvs is called only during debugging.  Review them from time to time.
#if FORCEVIRTUALINPUTS==2
#define rifvsdebug(x)               rifvs(x)
#else
#define rifvsdebug(x)               (x)
#endif
#define reaxis(x,y)                 jtreaxis(jt,(x),(y))
#define recip(x)                    jtrecip(jt,(x),ds(CDIV))   
#define rect(x)                     jtrect(jt,(x),ds(CPLUSDOT))
#define red0(x,y)                   jtred0(jt,(x),(y))
#define redcat(x,y)                 jtredcat(jt,(x),(y))
#define redcatsp(x,y,z)             jtredcatsp(jt,(x),(y),(z))
#define redef(x,y)                  jtredef(jt,(x),(y))
#define redefg(x)                   jtredefg(jt,0,(x))
#define redg(x,y)                   jtredg(jtinplace,(x),(y))
#define redsp1(x0,x1,x2,x3,x4,x5,x6,x7)             jtredsp1(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7))
#define redsp1a(x0,x1,x2,x3,x4,x5)                  jtredsp1a(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define redspd(x0,x1,x2,x3,x4,x5,x6,x7)             jtredspd(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7))
#define redsps(x0,x1,x2,x3,x4,x5,x6,x7)             jtredsps(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7))
#define redspse(x0,x1,x2,x3,x4,x5,x6,x7)            jtredspse(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7))
#define redspsprep(x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12)  jtredspsprep(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7),(x8),(x9),(x10),(x11),(x12))
#define reduce(x,y)                 jtreduce(jt,(x),(y))
#define reduce2(x0,x1,x2,x3,x4)     jtreduce2(jt,(x0),(x1),(x2),(x3),(x4))
#define reducesp(x,y)               jtreducesp(jt,(x),(y))
#define reitem(x,y)                 jtreitem(jt,(x),(y)) 
#define remdd(x,y)                  jtremdd(jt,(x),(y))
#define remid(x,y)                  jtremid(jt,(x),(y))
#define rep1d(x0,x1,x2,x3)          jtrep1d(jt,(x0),(x1),(x2),(x3))
#define rep1s(x0,x1,x2,x3)          jtrep1s(jt,(x0),(x1),(x2),(x3))
#define rep1sa(x,y,z)               jtrep1sa(jt,(x),(y),(z))
#define repbdx(x0,x1,x2,x3)         jtrepbdx(jtinplace,(x0),(x1),(x2),(x3))
#define repbsx(x0,x1,x2,x3)         jtrepbsx(jt,(x0),(x1),(x2),(x3))
#define repeat(x,y)                 jtrepeat(jt,(x),(y)) 
#define repeatr(x,y)                jtrepeatr(jt,(x),(y))
#define repidx(x0,x1,x2,x3)         jtrepidx(jt,(x0),(x1),(x2),(x3))
#define repisx(x0,x1,x2,x3)         jtrepisx(jt,(x0),(x1),(x2),(x3))
#define repzdx(x0,x1,x2,x3)         jtrepzdx(jt,(x0),(x1),(x2),(x3))
#define repzsx(x0,x1,x2,x3)         jtrepzsx(jt,(x0),(x1),(x2),(x3))
#define reshape(x,y)                jtreshape(jt,(x),(y))
#define reshapeW(x,y)               jtreshape((J)((I)jt|JTINPLACEW),(x),(y))
#define reshapesp(x0,x1,x2,x3)      jtreshapesp(jt,(x0),(x1),(x2),(x3))
#define reshapesp0(x0,x1,x2,x3)     jtreshapesp0(jt,(x0),(x1),(x2),(x3))
#define residue(x,y)                jtresidue(jt,(x),(y),ds(CSTILE))
#define reverse(x)                  jtreverse(jt,(x)) 
#define revsp(x)                    jtrevsp(jt,(x)) 
#define rezero(x,y)                 jtrezero(jt,(x),(y))
#define rfc(x)                      jtrfc(jt,(x))
#define rfcq(x0,x1,x2,x3)           jtrfcq(jt,(x0),(x1),(x2),(x3))
#define rfcz(x,y)                   jtrfcz(jt,(x),(y))
#define rfd(x)                      jtrfd(jt,(x))
#define rinv(x)                     jtrinv(jt,(x))
#define rmdir1(x)                   jtrmdir1(jt,(x))
#define rngga(x,y)                  jtrngga(jt,(x),(y))
#define rngseeds(x)                 jtrngseeds(jt,(x))
#define rngselects(x)               jtrngselects(jt,(x))
#define rngstates1(x0,x1,x2,x3,x4,x5,x6)         jtrngstates1(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6))
#define roll(x)                     jtroll(jt,(x))
#define roll2(x,y)                  jtroll2(jt,(x),(y))
#define rollany(x,y)                jtrollany(jt,(x),(y))
#define rollbool(x)                 jtrollbool(jt,(x))
#define rollk(x,y,z)                jtrollk(jt,(x),(y),(z))    
#define rollksub(x,y)               jtrollksub(jt,(x),(y))  // FIXME: invalid
#define rollnot0(x,y)               jtrollnot0(jt,(x),(y))
#define rollxnum(x)                 jtrollxnum(jt,(x))
#define root(x,y)                   jtroot(jt,(x),(y)) 
#define rot(x0,x1,x2,x3,x4,x5,x6,x7)                jtrot(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7))  
#define rotate(x,y)                 jtrotate(jt,(x),(y)) 
#define rotsp(x,y)                  jtrotsp(jt,(x),(y))
#define roundID(x,y)                jtroundID(jt,(x),(y))
#define rrv(x)                      ((UI)((x)->lrr)&RANKTMSK)  // rr of V
#define rr(x)                       rrv(FAV(x))  // rr of A
#define rsh0(x)                     jtrsh0(jt,(x))
#define rtrim(x)                    jtrtrim(jt,(x))
#define rsort(x)                    jtrsort(jt,(x))
#define sb2(x,y)                    jtsb2(jt,(x),(y))
#define sbbox(x)                    jtsbbox(jt,(x))
#define sbcheck(x)                  jtsbcheck(jt,(x))
#define sbcheck1(x0,x1,x2,x3,x4,x5,x6,x7,x8)           jtsbcheck1(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7),(x8))
#define sbcheck2(x0,x1,x2,x3)       jtsbcheck2(jt,(x0),(x1),(x2),(x3))
#define sbextend(x0,x1,x2,x3)       jtsbextend(jt,(x0),(x1),(x2),(x3))
#define sbgetdata(x)                jtsbgetdata(jt,(x))
#define sbhashstat(x)               jtsbhashstat(jt,(x))
#define sbinsert(x0,x1,x2,x3,x4) jtsbinsert(jt,(x0),(x1),(x2),(x3),(x4))
#define sblit(x,y)                  jtsblit(jt,(x),(y))
#define sborder(x)                  jtsborder(jt,(x))
#define sbprobe(x0,x1,x2,x3)        jtsbprobe(jt,(x0),(x1),(x2),(x3))
#define sbsetdata(x)                jtsbsetdata(jt,(x))
#define sbsetdata2(x)               jtsbsetdata2(jt,(x))
#define sbstr(x,y)                  jtsbstr(jt,(x),(y))
#define sbtestbox(x)                jtsbtestbox(jt,(x))
#define sbunbox(x)                  jtsbunbox(jt,(x))
#define sbunind(x)                  jtsbunind(jt,(x))
#define sbunlit(x,y)                jtsbunlit(jt,(x),(y))
#define sbunstr(x,y)                jtsbunstr(jt,(x),(y))
#define sc(x)                       jtsc(jt,(x))
#define sc4(x,y)                    jtsc4(jt,(x),(y))
#define scansp(x,y,z)               jtscansp(jt,(x),(y),(z))
#define scb(x)                      jtscb(jt,(x))
#define scc(x)                      jtscc(jt,(x))
#define scf(x)                      jtscf(jt,(x))
#define scfn(x,y)                   jtscfn(jt,(x),(y))
#define scheck(x)                   jtscheck(jt,(x))
#define scib(x)                     jtscib(jt,(x))
#define scind(x)                    jtscind(jt,(x))
#define scuba(x,y,z)                jtscuba(jt,(x),(y),(z))
#define scubb(x,y)                  jtscubb(jt,(x),(y))
#define scubc(x,y,z)                jtscubc(jt,(x),(y),(z))
#define scube(x,y,z)                jtscube(jt,(x),(y),(z))
#define scx(x)                      jtscx(jt,(x))
#define seecall(x)                  jtseecall(jt,(x))
#define seeparse(x)                 jtseeparse(jt,(x))
#define seg(x,y)                    jtseg(jt,(x),(y))   
#define selfq(x)                    jtselfq(jt,(x))
#define hasimploc(x)                jthasimploc(jt,(x))
#define selm(x)                     jtselm(jt,(x))
#define selx(x,y,z)                 jtselx(jt,(x),(y),(z))
#define sely(x0,x1,x2,x3)           jtsely(jt,(x0),(x1),(x2),(x3))
#define sent12b(x)              jtsent12b(jt,(x))
#define sent12c(x)            jtsent12c(jt,(x))
#define setfv(x,y)                  jtsetfv(jt,(x),(y))
#define setleakcode(x)              jtsetleakcode(jt,(x))
#define sfn(x,y)                    jtsfn(jt,(x),(y))
#define sfne(x)                     jtsfne(jt,(x))
#define shape(x)                    jtshape(jt,(x))   
#define shasum2(x,y)                jtshasum2(jt,(x),(y),DUMMYSELF)
#define shift1(x)                   jtshift1(jt,(x))
#define shift10(x,y)                jtshift10(jt,(x),(y))
#define showerr()                   jtshowerr(jt)
#define signum(x)                   jtatomic1(jt,(x),ds(CSTAR))  
#define slash(x)                    jtslash(jt,(x))   
#define sldot(x)                    jtsldot(jt,(x))
#define sm_init(x)                  jtsm_init(jt,(x))
#define smallprimes(x0,x1,x2,x3)    jtsmallprimes(jt,(x0),(x1),(x2),(x3))
#define smma(x,y)                   jtsmma(jt,(x),(y))
#define smmblkf(x)                  jtsmmblkf(jt,(x))
#define smmblku(x)                  jtsmmblku(jt,(x))
#define smmcar(x,y)                 jtsmmcar(jt,(x),(y))
#define smmga(x0,x1,x2,x3,x4)       jtsmmga(jt,(x0),(x1),(x2),(x3),(x4))
#define smmin(x,y)                  jtsmmin(jt,(x),(y))
#define smminit(x)                  jtsmminit(jt,(x))
#define smmis(x,y)                  jtsmmis(jt,(x),(y))
#define smmjoin(x,y)                jtsmmjoin(jt,(x),(y))
#define snl(x)                      jtsnl(jt,(x))
#define sortb(x0,x1,x2)             jtsortb(jtinplace,(x0),(x1),(x2))
#define sortb2(x0,x1,x2)            jtsortb2(jtinplace,(x0),(x1),(x2))
#define sortb4(x0,x1,x2)            jtsortb4(jtinplace,(x0),(x1),(x2))
#define sortc(x0,x1,x2)             jtsortc(jtinplace,(x0),(x1),(x2))
#define sortc2(x0,x1,x2)            jtsortc2(jtinplace,(x0),(x1),(x2))
#define sortu(x0,x1,x2)             jtsortu(jtinplace,(x0),(x1),(x2))
#define sortu1(x0,x1,x2)            jtsortu1(jtinplace,(x0),(x1),(x2))
#define sortd(x0,x1,x2)             jtsortd(jtinplace,(x0),(x1),(x2))
#define sorti(x0,x1,x2)             jtsorti(jtinplace,(x0),(x1),(x2))
#define sorti1(x0,x1,x2)            jtsorti1(jtinplace,(x0),(x1),(x2))
#define sp(x)                       jtsp(jt,(x))
#define sparse1(x)                  jtsparse1(jt,(x)) 
#define sparse1a(x0,x1,x2,x3,x4)    jtsparse1a(jt,(x0),(x1),(x2),(x3),(x4))
#define sparseit(x,y,z)             jtsparseit(jt,(x),(y),(z))
#define sparsen1(x)                 jtsparsen1(jt,(x))
#define sparsep1(x)                 jtsparsep1(jt,(x))
#define spres(x)                    jtspres(jt,(x))
#define spbytesinuse()              jtspbytesinuse(jt)
#define spstarttracking()           jtspstarttracking(jt)
#define spendtracking()             jtspendtracking(jt)
#define spc()                       jtspc(jt)
#define spdscell(x0,x1,x2,x3,x4)    jtspdscell(jt,(x0),(x1),(x2),(x3),(x4))
#define spella(x)                   jtspella(jt,(x))
#define spellcon(x)                 jtspellcon(jt,(x))
#define spellout(x)                 jtspellout(jt,(x))
#define spfor1(x)                   jtspfor1(jt,(x))
#define spfree()                    jtspfree(jt)
#define splitij(x,y,z)              jtsplitij(jt,(x),(y),(z))
#define spmult(x0,x1,x2,x3,x4,x5,x6,x7)             jtspmult(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7))
#define spmultdo(x0,x1,x2,x3)       jtspmultdo(jt,(x0),(x1),(x2),(x3))
#define spradv(x0,x1,x2,x3,x4,x5,x6)                jtspradv(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6))
#define sprank1(x0,x1,x2,x3)        jtsprank1(jt,(x0),(x1),(x2),(x3))
#define sprank2(x0,x1,x2,x3,x4,x5)  jtsprank2(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define sprank2_0w(x0,x1,x2,x3,x4,x5)               jtsprank2_0w(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define sprank2_a0(x0,x1,x2,x3,x4,x5)               jtsprank2_a0(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define sprarg(x,y)                 jtsprarg(jt,(x),(y)) 
#define spredge(x,y,z)              jtspredge(jt,(x),(y),(z))  
#define sprinit(x0,x1,x2,x3,x4)     jtsprinit(jt,(x0),(x1),(x2),(x3),(x4))
#define sprintfeD(x0,x1,x2,x3,x4)   jtsprintfeD(jt,(x0),(x1),(x2),(x3),(x4))
#define sprintfnD(x0,x1,x2,x3,x4)   jtsprintfnD(jt,(x0),(x1),(x2),(x3),(x4))
#define sprintfI(x0,x1,x2,x3,x4)    jtsprintfI(jt,(x0),(x1),(x2),(x3),(x4))
#define sprz(x0,x1,x2,x3,x4)        jtsprz(jt,(x0),(x1),(x2),(x3),(x4))
#define spspd(x0,x1,x2,x3)          jtspspd(jt,(x0),(x1),(x2),(x3))
#define spspi(x0,x1,x2,x3)          jtspspi(jt,(x0),(x1),(x2),(x3))
#define spspx(x0,x1,x2,x3)          jtspspx(jt,(x0),(x1),(x2),(x3))
#define spsscell(x0,x1,x2,x3,x4)    jtspsscell(jt,(x0),(x1),(x2),(x3),(x4))
#define sqroot(x)                   jtatomic1(jt,(x),ds(CROOT))  
#define square(x)                   jtsquare(jt,(x))  
#define sscan(x,y)                  jtsscan(jt,(x),(y))
#define ssdo(x,y,z)                 jtssdo(jt,(x),(y),(z))
#define ssel(x,y)                   jtssel(jt,(x),(y))
#define ssg(x,y)                    jtssg(jt,(x),(y))
#define ssgu(x,y)                   jtssgu(jt,(x),(y))
#define sslope(x,y,z)               jtsslope(jt,(x),(y),(z))
#define ssnext(x,y)                 jtssnext(jt,(x),(y))
#define stcreate(x0,x1,x2,x3)       jtstcreate(jt,(x0),(x1),(x2),(x3))
#define stdf(x)                     jtstdf(jt,(x))
#define stdnm(x)                    jtstdnm(jt,(x))
#define stfind(x,y,z)               jtstfind(jt,(x),(y),(z))
#define stfindcre(x,y,z)            jtstfindcre(jt,(x),(y),(z))
#define stitch(x,y)                 jtstitch(jt,(x),(y),ds(CCOMDOT)) 
#define stitchsp2(x,y)              jtstitchsp2(jt,(x),(y),ds(CCOMDOT)) 
#define str(x,y)                    jtstr(jt,(x),(y))
#define strq(x,y)                   jtstrq(jt,(x),(y))
#define str0(x)                     jtstr0(jt,(x))
#define suffix(x,y)                 jtsuffix(jt,(x),(y))
#define sumatgbool(x,y,z)           jtsumatgbool(jt,(x),(y),(z))
#define sumattymes1(x,y,z)          jtsumattymes1(jt,(x),(y),(z))
#define summag(x)                   jtsummag(jt,(x))
#define sup(x,y)                    jtsup(jt,(x),(y))
#define suq(x,y)                    jtsuq(jt,(x),(y))
#define susp(x)                     jtsusp(jt,(x))
#define swap(x)                     jtswap(jt,(x)) 
#define swapc(x)                    jtswapc(jt,(x)) 
#define symbis(x,y,z)               jtsymbis(jt,(x),(y),(z))
#define symbisdel(x,y,z)            jtsymbisdel(jt,(x),(y),(z))
#define symbrd(x)                   jtsymbrd(jt,(x))
#define symbrdlock(x)               jtsymbrdlock(jt,(x))
#define symbrdlocknovalerr(x)       jtsymbrdlocknovalerr(jt,(x))
#define symfreeha(x)                jtsymfreeha(jt,(x))
#define symnew(x,y)                 jtsymnew(jt,(x),(y))
#define sympoola(x)                 jtsympoola(jt,0,(x))
#define sybaseloc(x)                jtsybaseloc(jt,(x))
#define syrdfromloc(x,y)            jtsyrdfromloc(jt,(x),(y))
#define syrd(x,y)                   jtsyrd(jt,(x),(y))
#define syrdforlocale(x)            jtsyrdforlocale(jt,(x))
#define syrdnobuckets(x)            jtsyrdnobuckets(jt,(x))
#define table(x)                    jttable(jt,(x))   
#define tail(x)                     jttail(jt,(x))    
#define take(x,y)                   jttake(jt,(x),(y))   
#define taker(x,y)                  jttaker(jt,(x),(y))   
#define tally(x)                    jttally(jt,(x))   
#define tayamp(x0,x1,x2,x3)         jttayamp(jt,(x0),(x1),(x2),(x3))
#define tayatop(x)                  jttayatop(jt,(x))
#define tayfolk(x)                  jttayfolk(jt,(x))
#define tayinv(x,y)                 jttayinv(jt,(x),(y))
#define taysum(x)                   jttaysum(jt,(x))
#define tcap(x,y)                   jttcap(jt,(x),(y))   
#define tceil(x)                    jttceil(jt,(x)) 
#define eceil(x)                    jteceil(jt,(x)) 
#define tclosure(x,y)               jttclosure(jt,(x),(y))   
#define tco(x)                      jttco(jt,(x))     
#define tcoamp(x0,x1,x2,x3)         jttcoamp(jt,(x0),(x1),(x2),(x3))
#define tconnect(x)                 jttconnect(jt,(x))
#define tdot(x)                     jttdot(jt,(x))   
#define teq(x,y)                    jtteq(jt,(x),(y))
#define tesa(x,y)                   jttesa(jt,(x),(y))
#define tesatrunc(x,y)              jttesatrunc(jt,(x),(y))
#define tesmat(x0,x1,x2,x3,x4)      jttesmat(jt,(x0),(x1),(x2),(x3),(x4))
#define tesmatu(x0,x1,x2,x3,x4)     jttesmatu(jt,(x0),(x1),(x2),(x3),(x4))
#define tesos(x,y,z,w)              jttesos(jt,(x),(y),(z),(w))
#define tess2(x,y,z)                jttess2(jt,(x),(y),(z))
#define tf()                        jttf(jt)
#define tfloor(x)                   jttfloor(jt,(x)) 
#define efloor(x)                   jtefloor(jt,(x)) 
#define tg(x)                       jttg(jt,(x))
#define th2a(x0,x1,x2,x3,x4,x5,x6,x7,x8,x9)            jtth2a(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7),(x8),(x9))
#define th2box(x,y)                 jtth2box(jt,(x),(y))
#define th2c(x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10)         jtth2c(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7),(x8),(x9),(x10))
#define th2ctrl(x0,x1,x2,x3,x4,x5)  jtth2ctrl(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define thbit(x)                    jtthbit(jt,(x))
#define thb(x)                      jtthb(jt,(x))
#define thbox(x,y)                  jtthbox(jt,(x),(y))
#define thdx1(x)                    jtthdx1(jt,(x))
#define thn(x)                      jtthn(jt,(x))
#define thorn1(x)                   jtthorn1(jt,(x))  
#define thorn1main(x,y)             jtthorn1main(jt,(x),(y))  
#define thorn1u(x)                  jtthorn1u(jt,(x))  
#define thq1(x)                     jtthq1(jt,(x))
#define ths(x)                      jtths(jt,(x))
#define thsb(x,y)                   jtthsb(jt,(x),(y))
#define thv(x,y,z)                  jtthv(jt,(x),(y),(z))
#define thx1(x)                     jtthx1(jt,(x))
#define thxqe(x)                    jtthxqe(jt,(x))
#define tie(x,y)                    jttie(jt,(x),(y))
#define tine(x)                     jttine(jt,(x),tmonad)
#define tk(x,y)                     jttk(jt,(x),(y)) 
#define tk0(x,y,z)                  jttk0(jt,(x),(y),(z)) 
#define tks(x,y)                    jttks(jt,(x),(y)) 
#define tleaf(x)                    jttleaf(jt,(x))
#define tlt(x,y)                    jttlt(jt,(x),(y))
#define toc1(x,y)                   jttoc1(jt,(x),(y))
#define toc2(x)                     jttoc2(jt,(x))
#define toc2e(x)                    jttoc2e(jt,(x))
#define tokens(x,y)                 jttokens(jt,(x),(y))
#define totient(x)                  jttotient(jt,(x))
#define toutf8(x)                   jttoutf8(jt,(x))
#define toutf8a(x,y)                jttoutf8a(jt,(x),(y))
#define toutf8x(x)                  jttoutf8x(jt,(x))
#define tomutf8(x)                  jttomutf8(jt,(x))
#define tocesu8(x)                  jttocesu8(jt,(x))
#define toutf16(x)                  jttoutf16(jt,(x))
#define toutf32(x)                  jttoutf32(jt,(x))
#define tou32(x)                    jttou32(jt,(x))
#define toutf16x(x)                 jttoutf16x(jt,(x))
#define tparse(x)                   jttparse(jt,(x))
#define tpoly(x)                    jttpoly(jt,(x))
#define tpop(x)                     jttpop(jt,(x),jt->tnextpushp)
// if tg() fails, tpush leaves nextpushx unchanged
// Handle top level of tpush().  push the current block, and recur if it is traversible and does not have recursive usecount BUT NOTE: we have ensured that EPILOG always does ra() on z,
//  which means that the only nonrecursive blocks that are tpush()ed are nonrecursiblw; and those are all sparse.  Thus, we recur on sparse arguments only
// We can have an inplaceable but recursible block, if it was gc'd.  We never push a PERMANENT block, so that we won't try to free it
// NOTE that PERMANENT blocks are always marked traversible if they are of traversible type, so we will not recur on them internally
// If this fails, the block is not pushed but the system can keep running
#define tpushcommon(x,cksparse,suffix) {if(likely(!ACISPERM(AC(x)))){I tt=AT(x); A *pushp=jt->tnextpushp; *pushp++=(x); \
                              if(unlikely(!((I)pushp&(NTSTACKBLOCK-1)))){RZ(pushp=tg(pushp));} if(unlikely(cksparse&&ISSPARSE(tt)))RZ(pushp=jttpush(jt,(x),tt,pushp)); jt->tnextpushp=pushp; suffix}}
#define tpush(x)              tpushcommon(x,1,if(MEMAUDIT&2)audittstack(jt);)
#define tpushna(x)            tpushcommon(x,1,)   // suppress audit
#define tpushnr(x)            tpushcommon(x,0,if(MEMAUDIT&2)audittstack(jt);)   // suppress recursion
// Internal version, used when the local name pushp is known to hold jt->tnextpushp
#define tpushi(x)                   {if(likely(!ACISPERM(AC(x)))){I tt=AT(x); *pushp++=(x); if(unlikely(!((I)pushp&(NTSTACKBLOCK-1)))){RZ(pushp=tg(pushp));} if(unlikely(ISSPARSE(tt)))RZ(pushp=jttpush(jt,(x),tt,pushp)); }}
// tpush1 is like tpush, but it does not recur to lower levels.  Used only for virtual block (which cannot be PERMANENT)
#define tpush1(x)                   {A *pushp=jt->tnextpushp; *pushp++=(x); if(unlikely(!((I)pushp&(NTSTACKBLOCK-1)))){RZ(pushp=tg(pushp));} jt->tnextpushp=pushp; if(MEMAUDIT&2)audittstack(jt);}
#define trc(x)                      jttrc(jt,(x))     
#define treach(x)                   jttreach(jt,(x))
#define trep(x)                     jttrep(jt,(x))
#define tridiag(x,y,z)              jttridiag(jt,(x),(y),(z))
#define troot(x,y)                  jttroot(jt,(x),(y))
#define trr(x)                      jttrr(jt,(x))
#define tryinit(x,y,z)              jttryinit(jt,(x),(y),(z))
#define ts(x)                       jtts(jt,(x))
#define tsit2(x,y)                  jttsit2(jt,(x),(y),DUMMYSELF)
#define tymes(x,y)                  jtatomic2(jt,(x),(y),ds(CSTAR))
#define tymesA(x,y)                 jtatomic2((J)((I)jt|JTINPLACEA),(x),(y),ds(CSTAR))
#define tymesAW(x,y)                jtatomic2((J)((I)jt|JTINPLACEA|JTINPLACEW),(x),(y),ds(CSTAR))
#define tymesW(x,y)                 jtatomic2((J)((I)jt|JTINPLACEW),(x),(y),ds(CSTAR))
#define uco1(x)                     jtuco1(jt,(x))
#define uco2(x,y)                   jtuco2(jt,(x),(y))
#define unbinr(x0,x1,x2,x3,x4,x5)   jtunbinr(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define under(x,y)                  jtunder(jt,(x),(y))  
#define unh(x)                      jtunh(jt,(x))
#define unhex(x)                    jtunhex(jt,(x))
#define unlj(x)                     jtunlj(jt,(x))
#define unlk(x)                     jtunlk(jt,(x))
#define unlock1(x)                  jtunlock1(jt,(x))
#define unlock2(x,y)                jtunlock2(jt,(x),(y))
#define unname(x)                   jtunname(jt,(x),0)
#define unparse(x)                  jtunparse(jt,(x),0)
#define unparse1(x0,x1,x2,x3)       jtunparse1(jt,(x0),(x1),(x2),(x3))
#define unparse1a(x,y,z)            jtunparse1a(jt,(x),(y),(z))
#define unparsem(x,y)               jtunparsem(jt,(x),(y))
#define unquote(x,y,z)              jtunquote(jt,(x),(y),(z))
#define unstackcv(x,y)              jtunstackcv(jt,(x),(y))
#define unwordil(x,y,z)             jtunwordil(jt,(x),(y),(z))
#define unzero(x)                   jtunzero(jt,(x))
#define upon2(x,y,z)                jtupon2(jt,(x),(y),(z))
#define uponf2(x,y,z)               jtuponf2(jt,(x),(y),(z))
#define usebs(x,y,z)                jtusebs(jt,(x),(y),(z))
#define utype(x,y)                  jtutype(jt,(x),(y))
#define v2(x,y)                     jtv2(jt,(x),(y))
#define va1(x,y)                    jtva1(jt,(x),(y))
#define va1s(x0,x1,x2,x3)           jtva1s(jt,(x0),(x1),(x2),(x3))
#define vaid(x)                     jtvaid(jt,(x))
#define var(x0,x1,x2)               jtvar(jt,(x0),(x1),(x2))
// fetch adocv for an rps function (i. e. f/ f/\ f/\.) in self.  rps is 0-2 for / /\ /\.   t is the type of the input.  Assign result to z, which is a VARPS
#define varps(z,self,t,rps) {VARPSA *rpsa=FAV(self)->localuse.lu1.redfn; I tmax=rpsa->nprec; if(likely(jt->jerr<EWOV)){I zc=CTTZI(t); VARPS *az=&rpsa->actrtns[tmax*(rps)+zc]; az=zc>=tmax?&rpsnull.actrtns[0]:az; z=*az;}else{RESETERR; z=rpsa->actrtns[3*tmax+(rps)];}  }
#define vasp(x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12)     jtvasp(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7),(x8),(x9),(x10),(x11),(x12))
#define vasp0(x0,x1,x2,x3,x4,x5)                            jtvasp0(jt,(x0),(x1),(x2),(x3),(x4),(x5))
#define vaspc(x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12)    jtvaspc(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7),(x8),(x9),(x10),(x11),(x12))
#define vaspeq(x0,x1,x2,x3,x4,x5,x6,x7,x8)                  jtvaspeq(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7),(x8))
#define vaspeqprep(x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11)   jtvaspeqprep(jt,(x0),(x1),(x2),(x3),(x4),(x5),(x6),(x7),(x8),(x9),(x10),(x11))
#define vaspz(x)                    jtvaspz(jt,(x))
#define vaxis(x,y)                  jtvaxis(jt,(x),(y))
#define vc1(x,y)                    jtvc1(jt,(x),(y))
#define vci(x)                      jtvci(jt,(x))
#define vec(x,y,z)                  jtvec(jt,(x),(y),(z))
#define vecb01(x,y,z)               jtvecb01(jt,(x),(y),(z))
#define vfinal(x)                   jtvfinal(jt,(x))
#define vfn(x)                      jtvfn(jt,(x))
#define vger2(x,y,z)                jtvger2(jt,(x),(y),(z))
#define vi(x)                       jtvi(jt,(x))
#define vib(x)                      jtvib(jt,(x))
#define vip(x)                      jtvip(jt,(x))
#define virtual(x,y,z)              jtvirtual(jt,(x),(y),(z))
#define virtualip(x,y,z)            jtvirtual(jtinplace,(x),(y),(z))
#define vlocnl(x,y)                 jtvlocnl(jt,(x),(y))
#define vmove(x,y,z)                jtvmove(jt,(x),(y),(z))
#define vnm(x,y)                    jtvnm(jt,(x),(y))
#define vs(x)                       jtvs(jt,(x))
#define vslit(x)                    jtvslit(jt,(x))
#define vtokens(x)                  jtvtokens(jt,(x))
#define vtrans(x)                   jtvtrans(jt,(x))
#define wa(x,y,z)                   jtwa(jt,(x),(y),(z))
#define weight(x,y)                 jtweight(jt,(x),(y)) 
#define widthdp(x,y,z)              jtwidthdp(jt,(x),(y),(z)) 
#define wordil(x)                   jtwordil(jt,(x))
#define words(x)                    jtwords(jt,(x),ds(CWORDS)) 
#define x10(x)                      XpowUU(10,e) // 10^e as a rational number
#define xbin(x,y)                   jtxbin(jt,(x),(y))
#define xbinp(x,y)                  jtxbinp(jt,(x),(y))
#define xc(x)                       jtxc(jt,(x))
#define xco1(x)                     jtxco1(jt,(x))    
#define xco2(x,y)                   jtxco2(jt,(x),(y))
#define xcompare(x,y)               jtxcompare(jt,(x),(y))
#define xdefn(x,y,z)                jtxdefn(jt,(x),(y),(z))
#define xd1(x,y)                      jtxd1(jt,(x),(y))
#define xdiv(x,y,z)                 jtxdiv(jt,(x),(y),(z))
#define xdivrem(x0,x1,x2,x3)        jtxdivrem(jt,(x0),(x1),(x2),(x3))
#define xev1(x,y)                   jtxev1(jt,(x),(y))
#define xev2(x,y,z)                 jtxev2(jt,(x),(y),(z))
#define xexp(x,y)                   jtxexp(jt,(x),(y))
#define xfact(x)                    jtxfact(jt,(x))
#define xfactor(x)                  jtxfactor(jt,(x))
#define xgcd(x,y)                   jtxgcd(jt,(x),(y))
#define xint(x)                     jtxint(jt,(x))
#define xlcm(x,y)                   jtxlcm(jt,(x),(y))
#define xlog1(x)                    jtxlog1(jt,(x))
#define xlog2(x,y)                  jtxlog2(jt,(x),(y))
#define xlog2sub(x,y)               jtxlog2sub(jt,(x),(y))
#define xlogabs(x)                  jtxlogabs(jt,(x))
#define xlogd1(x)                   jtxlogd1(jt,(x))
#define xlogz1(x)                   jtxlogz1(jt,(x))
#define xminus(x,y)                 jtxminus(jt,(x),(y))
#define xmodpow(x,y,z)              jtxmodpow(jt,(x),(y),(z))
#define xop(x)                      jtxop(jt,(x))
#define xop2(x,y,z)                 jtxop2(jt,(x),(y),(z))
#define xopcall(x)                  jtxopcall(jt,(x))
#define xpi(x)                      jtxpi(jt,(x))
#define xplus(x,y)                  jtxplus(jt,(x),(y))
#define xpow(x,y)                   jtxpow(jt,(x),(y))
#define xprimeq(x,y)                jtxprimeq(jt,(x),(y)) 
#define xprimetest(x)               jtxprimetest(jt,(x))
#define Xmpzcommon(x,b)             jtXmpzcommon(jt,(x),b)
#define xrand(x)                    jtxrand(jt,(x))
#define xrem(x,y)                   jtxrem(jt,(x),(y))
#define xrep(x,y)                   jtxrep(jt,(x),(y))
#define xroot(x,y)                  jtxroot(jt,(x),(y))
#define xsgn(x)                     jtxsgn(jt,(x))
#define xsq(x)                      jtxsq(jt,(x))
#define xsqrt(x)                    jtxsqrt(jt,(x))
#define xstd(x)                     jtxstd(jt,(x))
#define xtymes(x,y)                 jtxtymes(jt,(x),(y))
#define xquad(z,w)                  jtxquad(jt,(z),(w))
#define zacos(x)                    jtzacos(jt,(x))
#define zacosh(x)                   jtzacosh(jt,(x))
#define zarc(x)                     jtzarc(jt,(x))
#define zasin(x)                    jtzasin(jt,(x))
#define zasinh(x)                   jtzasinh(jt,(x))
#define zatan(x)                    jtzatan(jt,(x))
#define zatanh(x)                   jtzatanh(jt,(x))
#define zbin(x,y)                   jtzbin(jt,(x),(y))
#define zceil(x)                    jtzceil(jt,(x))
#define zcir(x,y)                   jtzcir(jt,(x),(y))
#define zconjug(x)                  jtzconjug(jt,(x))
#define zcos(x)                     jtzcos(jt,(x))
#define zcosh(x)                    jtzcosh(jt,(x))
#define zdiv(x,y)                   jtzdiv(jt,(x),(y))
#define zeq(x,y)                    jtzeq(jt,(x),(y))
#define zexp(x)                     jtzexp(jt,(x))
#define zfloor(x)                   jtzfloor(jt,(x))
#define zgamma(x)                   jtzgamma(jt,(x))
#define zgauss(x,y)                 jtzgauss(jt,(x),(y))
#define zgcd(x,y)                   jtzgcd(jt,(x),(y))
#define zgps(x)                     jtzgps(jt,(x))
#define zgrecur(x)                  jtzgrecur(jt,(x))
#define zhorner(x,y,z)              jtzhorner(jt,(x),(y),(z))
#define zjx(x)                      jtzjx(jt,(x))
#define zlcm(x,y)                   jtzlcm(jt,(x),(y))
#define zlog(x)                     jtzlog(jt,(x))
#define zm4(x)                      jtzm4(jt,(x))
#define zminus(x,y)                 jtzminus(jt,(x),(y))
#define zmj(x)                      jtzmj(jt,(x))
#define znegate(x)                  jtznegate(jt,(x))
#define zp4(x)                      jtzp4(jt,(x))
#define zp8(x)                      jtzp8(jt,(x))
#define zpad1(x,y,z)                jtzpad1(jt,(x),(y),(z))
#define zpadn(x,y,z)                jtzpadn(jt,(x),(y),(z))
#define zplus(x,y)                  jtzplus(jt,(x),(y))
#define zpow(x,y)                   jtzpow(jt,(x),(y))
#define zrem(x,y)                   jtzrem(jt,(x),(y))
#define zsin(x)                     jtzsin(jt,(x))
#define zsinh(x)                    jtzsinh(jt,(x))
#define zsqrt(x)                    jtzsqrt(jt,(x))
#define zstirling(x)                jtzstirling(jt,(x))
#define ztan(x)                     jtztan(jt,(x))
#define ztanh(x)                    jtztanh(jt,(x))
#define ztrend(x)                   jtztrend(jt,(x))
#define ztridiag(x,y,z)             jtztridiag(jt,(x),(y),(z))
#define ztymes(x,y)                 jtztymes(jt,(x),(y))
